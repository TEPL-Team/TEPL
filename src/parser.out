Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> body
Rule 1     body -> stmt
Rule 2     body -> body stmt
Rule 3     stmt -> set_stmt
Rule 4     stmt -> output_stmt
Rule 5     stmt -> if_then_stmt
Rule 6     stmt -> input_stmt
Rule 7     stmt -> while_stmt
Rule 8     stmt -> repeat_stmt
Rule 9     var_stmt -> SET ID
Rule 10    set_stmt -> var_stmt TO expr
Rule 11    output_stmt -> OUTPUT expr
Rule 12    if_then_stmt -> IF expr THEN body END
Rule 13    input_stmt -> ASK expr
Rule 14    while_stmt -> WHILE condition DO body END
Rule 15    repeat -> REPEAT expr TIMES USING expr
Rule 16    repeat_stmt -> repeat body END
Rule 17    expr -> binop
Rule 18    expr -> condition
Rule 19    binop -> expr PLUS expr
Rule 20    binop -> expr MINUS expr
Rule 21    binop -> expr MULTIPLY expr
Rule 22    binop -> expr DIVIDE expr
Rule 23    condition -> expr GT expr
Rule 24    condition -> expr LT expr
Rule 25    condition -> expr ET expr
Rule 26    condition -> expr GTE expr
Rule 27    condition -> expr LTE expr
Rule 28    condition -> expr NE expr
Rule 29    condition -> expr AND expr
Rule 30    condition -> expr OR expr
Rule 31    expr -> DIGIT
Rule 32    expr -> ID
Rule 33    expr -> LPAREN expr RPAREN
Rule 34    expr -> RANDOM NUMBER FROM expr TO expr
Rule 35    expr -> TEXT
Rule 36    expr -> CONVERT expr TO datatype
Rule 37    datatype -> NUM
Rule 38    datatype -> TXT

Terminals, with rules where they appear

AND                  : 29
ASK                  : 13
COMMENT              : 
CONVERT              : 36
DIGIT                : 31
DIVIDE               : 22
DO                   : 14
END                  : 12 14 16
ET                   : 25
FROM                 : 34
GT                   : 23
GTE                  : 26
ID                   : 9 32
IF                   : 12
LPAREN               : 33
LT                   : 24
LTE                  : 27
MINUS                : 20
MULTIPLY             : 21
NE                   : 28
NUM                  : 37
NUMBER               : 34
OR                   : 30
OUTPUT               : 11
PLUS                 : 19
RANDOM               : 34
REPEAT               : 15
RPAREN               : 33
SET                  : 9
TEXT                 : 35
THEN                 : 12
TIMES                : 15
TO                   : 10 34 36
TXT                  : 38
USING                : 15
WHILE                : 14
error                : 

Nonterminals, with rules where they appear

binop                : 17
body                 : 2 12 14 16 0
condition            : 14 18
datatype             : 36
expr                 : 10 11 12 13 15 15 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 33 34 34 36
if_then_stmt         : 5
input_stmt           : 6
output_stmt          : 4
repeat               : 16
repeat_stmt          : 8
set_stmt             : 3
stmt                 : 1 2
var_stmt             : 10
while_stmt           : 7

Parsing method: LALR

state 0

    (0) S' -> . body
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (10) set_stmt -> . var_stmt TO expr
    (11) output_stmt -> . OUTPUT expr
    (12) if_then_stmt -> . IF expr THEN body END
    (13) input_stmt -> . ASK expr
    (14) while_stmt -> . WHILE condition DO body END
    (16) repeat_stmt -> . repeat body END
    (9) var_stmt -> . SET ID
    (15) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 10
    IF              shift and go to state 11
    ASK             shift and go to state 12
    WHILE           shift and go to state 13
    SET             shift and go to state 15
    REPEAT          shift and go to state 16

    body                           shift and go to state 1
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    var_stmt                       shift and go to state 9
    repeat                         shift and go to state 14

state 1

    (0) S' -> body .
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (10) set_stmt -> . var_stmt TO expr
    (11) output_stmt -> . OUTPUT expr
    (12) if_then_stmt -> . IF expr THEN body END
    (13) input_stmt -> . ASK expr
    (14) while_stmt -> . WHILE condition DO body END
    (16) repeat_stmt -> . repeat body END
    (9) var_stmt -> . SET ID
    (15) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 10
    IF              shift and go to state 11
    ASK             shift and go to state 12
    WHILE           shift and go to state 13
    SET             shift and go to state 15
    REPEAT          shift and go to state 16

    stmt                           shift and go to state 17
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    var_stmt                       shift and go to state 9
    repeat                         shift and go to state 14

state 2

    (1) body -> stmt .

    OUTPUT          reduce using rule 1 (body -> stmt .)
    IF              reduce using rule 1 (body -> stmt .)
    ASK             reduce using rule 1 (body -> stmt .)
    WHILE           reduce using rule 1 (body -> stmt .)
    SET             reduce using rule 1 (body -> stmt .)
    REPEAT          reduce using rule 1 (body -> stmt .)
    $end            reduce using rule 1 (body -> stmt .)
    END             reduce using rule 1 (body -> stmt .)


state 3

    (3) stmt -> set_stmt .

    OUTPUT          reduce using rule 3 (stmt -> set_stmt .)
    IF              reduce using rule 3 (stmt -> set_stmt .)
    ASK             reduce using rule 3 (stmt -> set_stmt .)
    WHILE           reduce using rule 3 (stmt -> set_stmt .)
    SET             reduce using rule 3 (stmt -> set_stmt .)
    REPEAT          reduce using rule 3 (stmt -> set_stmt .)
    $end            reduce using rule 3 (stmt -> set_stmt .)
    END             reduce using rule 3 (stmt -> set_stmt .)


state 4

    (4) stmt -> output_stmt .

    OUTPUT          reduce using rule 4 (stmt -> output_stmt .)
    IF              reduce using rule 4 (stmt -> output_stmt .)
    ASK             reduce using rule 4 (stmt -> output_stmt .)
    WHILE           reduce using rule 4 (stmt -> output_stmt .)
    SET             reduce using rule 4 (stmt -> output_stmt .)
    REPEAT          reduce using rule 4 (stmt -> output_stmt .)
    $end            reduce using rule 4 (stmt -> output_stmt .)
    END             reduce using rule 4 (stmt -> output_stmt .)


state 5

    (5) stmt -> if_then_stmt .

    OUTPUT          reduce using rule 5 (stmt -> if_then_stmt .)
    IF              reduce using rule 5 (stmt -> if_then_stmt .)
    ASK             reduce using rule 5 (stmt -> if_then_stmt .)
    WHILE           reduce using rule 5 (stmt -> if_then_stmt .)
    SET             reduce using rule 5 (stmt -> if_then_stmt .)
    REPEAT          reduce using rule 5 (stmt -> if_then_stmt .)
    $end            reduce using rule 5 (stmt -> if_then_stmt .)
    END             reduce using rule 5 (stmt -> if_then_stmt .)


state 6

    (6) stmt -> input_stmt .

    OUTPUT          reduce using rule 6 (stmt -> input_stmt .)
    IF              reduce using rule 6 (stmt -> input_stmt .)
    ASK             reduce using rule 6 (stmt -> input_stmt .)
    WHILE           reduce using rule 6 (stmt -> input_stmt .)
    SET             reduce using rule 6 (stmt -> input_stmt .)
    REPEAT          reduce using rule 6 (stmt -> input_stmt .)
    $end            reduce using rule 6 (stmt -> input_stmt .)
    END             reduce using rule 6 (stmt -> input_stmt .)


state 7

    (7) stmt -> while_stmt .

    OUTPUT          reduce using rule 7 (stmt -> while_stmt .)
    IF              reduce using rule 7 (stmt -> while_stmt .)
    ASK             reduce using rule 7 (stmt -> while_stmt .)
    WHILE           reduce using rule 7 (stmt -> while_stmt .)
    SET             reduce using rule 7 (stmt -> while_stmt .)
    REPEAT          reduce using rule 7 (stmt -> while_stmt .)
    $end            reduce using rule 7 (stmt -> while_stmt .)
    END             reduce using rule 7 (stmt -> while_stmt .)


state 8

    (8) stmt -> repeat_stmt .

    OUTPUT          reduce using rule 8 (stmt -> repeat_stmt .)
    IF              reduce using rule 8 (stmt -> repeat_stmt .)
    ASK             reduce using rule 8 (stmt -> repeat_stmt .)
    WHILE           reduce using rule 8 (stmt -> repeat_stmt .)
    SET             reduce using rule 8 (stmt -> repeat_stmt .)
    REPEAT          reduce using rule 8 (stmt -> repeat_stmt .)
    $end            reduce using rule 8 (stmt -> repeat_stmt .)
    END             reduce using rule 8 (stmt -> repeat_stmt .)


state 9

    (10) set_stmt -> var_stmt . TO expr

    TO              shift and go to state 18


state 10

    (11) output_stmt -> OUTPUT . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 19
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 11

    (12) if_then_stmt -> IF . expr THEN body END
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 28
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 12

    (13) input_stmt -> ASK . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 29
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 13

    (14) while_stmt -> WHILE . condition DO body END
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    condition                      shift and go to state 30
    expr                           shift and go to state 31
    binop                          shift and go to state 20

state 14

    (16) repeat_stmt -> repeat . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (10) set_stmt -> . var_stmt TO expr
    (11) output_stmt -> . OUTPUT expr
    (12) if_then_stmt -> . IF expr THEN body END
    (13) input_stmt -> . ASK expr
    (14) while_stmt -> . WHILE condition DO body END
    (16) repeat_stmt -> . repeat body END
    (9) var_stmt -> . SET ID
    (15) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 10
    IF              shift and go to state 11
    ASK             shift and go to state 12
    WHILE           shift and go to state 13
    SET             shift and go to state 15
    REPEAT          shift and go to state 16

    repeat                         shift and go to state 14
    body                           shift and go to state 32
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    var_stmt                       shift and go to state 9

state 15

    (9) var_stmt -> SET . ID

    ID              shift and go to state 33


state 16

    (15) repeat -> REPEAT . expr TIMES USING expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 34
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 17

    (2) body -> body stmt .

    OUTPUT          reduce using rule 2 (body -> body stmt .)
    IF              reduce using rule 2 (body -> body stmt .)
    ASK             reduce using rule 2 (body -> body stmt .)
    WHILE           reduce using rule 2 (body -> body stmt .)
    SET             reduce using rule 2 (body -> body stmt .)
    REPEAT          reduce using rule 2 (body -> body stmt .)
    $end            reduce using rule 2 (body -> body stmt .)
    END             reduce using rule 2 (body -> body stmt .)


state 18

    (10) set_stmt -> var_stmt TO . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 35
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 19

    (11) output_stmt -> OUTPUT expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

    OUTPUT          reduce using rule 11 (output_stmt -> OUTPUT expr .)
    IF              reduce using rule 11 (output_stmt -> OUTPUT expr .)
    ASK             reduce using rule 11 (output_stmt -> OUTPUT expr .)
    WHILE           reduce using rule 11 (output_stmt -> OUTPUT expr .)
    SET             reduce using rule 11 (output_stmt -> OUTPUT expr .)
    REPEAT          reduce using rule 11 (output_stmt -> OUTPUT expr .)
    $end            reduce using rule 11 (output_stmt -> OUTPUT expr .)
    END             reduce using rule 11 (output_stmt -> OUTPUT expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 20

    (17) expr -> binop .

    PLUS            reduce using rule 17 (expr -> binop .)
    MINUS           reduce using rule 17 (expr -> binop .)
    MULTIPLY        reduce using rule 17 (expr -> binop .)
    DIVIDE          reduce using rule 17 (expr -> binop .)
    GT              reduce using rule 17 (expr -> binop .)
    LT              reduce using rule 17 (expr -> binop .)
    ET              reduce using rule 17 (expr -> binop .)
    GTE             reduce using rule 17 (expr -> binop .)
    LTE             reduce using rule 17 (expr -> binop .)
    NE              reduce using rule 17 (expr -> binop .)
    AND             reduce using rule 17 (expr -> binop .)
    OR              reduce using rule 17 (expr -> binop .)
    OUTPUT          reduce using rule 17 (expr -> binop .)
    IF              reduce using rule 17 (expr -> binop .)
    ASK             reduce using rule 17 (expr -> binop .)
    WHILE           reduce using rule 17 (expr -> binop .)
    SET             reduce using rule 17 (expr -> binop .)
    REPEAT          reduce using rule 17 (expr -> binop .)
    $end            reduce using rule 17 (expr -> binop .)
    END             reduce using rule 17 (expr -> binop .)
    THEN            reduce using rule 17 (expr -> binop .)
    TIMES           reduce using rule 17 (expr -> binop .)
    RPAREN          reduce using rule 17 (expr -> binop .)
    TO              reduce using rule 17 (expr -> binop .)
    DO              reduce using rule 17 (expr -> binop .)


state 21

    (18) expr -> condition .

    PLUS            reduce using rule 18 (expr -> condition .)
    MINUS           reduce using rule 18 (expr -> condition .)
    MULTIPLY        reduce using rule 18 (expr -> condition .)
    DIVIDE          reduce using rule 18 (expr -> condition .)
    GT              reduce using rule 18 (expr -> condition .)
    LT              reduce using rule 18 (expr -> condition .)
    ET              reduce using rule 18 (expr -> condition .)
    GTE             reduce using rule 18 (expr -> condition .)
    LTE             reduce using rule 18 (expr -> condition .)
    NE              reduce using rule 18 (expr -> condition .)
    AND             reduce using rule 18 (expr -> condition .)
    OR              reduce using rule 18 (expr -> condition .)
    OUTPUT          reduce using rule 18 (expr -> condition .)
    IF              reduce using rule 18 (expr -> condition .)
    ASK             reduce using rule 18 (expr -> condition .)
    WHILE           reduce using rule 18 (expr -> condition .)
    SET             reduce using rule 18 (expr -> condition .)
    REPEAT          reduce using rule 18 (expr -> condition .)
    $end            reduce using rule 18 (expr -> condition .)
    END             reduce using rule 18 (expr -> condition .)
    THEN            reduce using rule 18 (expr -> condition .)
    TIMES           reduce using rule 18 (expr -> condition .)
    RPAREN          reduce using rule 18 (expr -> condition .)
    TO              reduce using rule 18 (expr -> condition .)
    DO              reduce using rule 18 (expr -> condition .)


state 22

    (31) expr -> DIGIT .

    PLUS            reduce using rule 31 (expr -> DIGIT .)
    MINUS           reduce using rule 31 (expr -> DIGIT .)
    MULTIPLY        reduce using rule 31 (expr -> DIGIT .)
    DIVIDE          reduce using rule 31 (expr -> DIGIT .)
    GT              reduce using rule 31 (expr -> DIGIT .)
    LT              reduce using rule 31 (expr -> DIGIT .)
    ET              reduce using rule 31 (expr -> DIGIT .)
    GTE             reduce using rule 31 (expr -> DIGIT .)
    LTE             reduce using rule 31 (expr -> DIGIT .)
    NE              reduce using rule 31 (expr -> DIGIT .)
    AND             reduce using rule 31 (expr -> DIGIT .)
    OR              reduce using rule 31 (expr -> DIGIT .)
    OUTPUT          reduce using rule 31 (expr -> DIGIT .)
    IF              reduce using rule 31 (expr -> DIGIT .)
    ASK             reduce using rule 31 (expr -> DIGIT .)
    WHILE           reduce using rule 31 (expr -> DIGIT .)
    SET             reduce using rule 31 (expr -> DIGIT .)
    REPEAT          reduce using rule 31 (expr -> DIGIT .)
    $end            reduce using rule 31 (expr -> DIGIT .)
    END             reduce using rule 31 (expr -> DIGIT .)
    THEN            reduce using rule 31 (expr -> DIGIT .)
    TIMES           reduce using rule 31 (expr -> DIGIT .)
    RPAREN          reduce using rule 31 (expr -> DIGIT .)
    TO              reduce using rule 31 (expr -> DIGIT .)
    DO              reduce using rule 31 (expr -> DIGIT .)


state 23

    (32) expr -> ID .

    PLUS            reduce using rule 32 (expr -> ID .)
    MINUS           reduce using rule 32 (expr -> ID .)
    MULTIPLY        reduce using rule 32 (expr -> ID .)
    DIVIDE          reduce using rule 32 (expr -> ID .)
    GT              reduce using rule 32 (expr -> ID .)
    LT              reduce using rule 32 (expr -> ID .)
    ET              reduce using rule 32 (expr -> ID .)
    GTE             reduce using rule 32 (expr -> ID .)
    LTE             reduce using rule 32 (expr -> ID .)
    NE              reduce using rule 32 (expr -> ID .)
    AND             reduce using rule 32 (expr -> ID .)
    OR              reduce using rule 32 (expr -> ID .)
    OUTPUT          reduce using rule 32 (expr -> ID .)
    IF              reduce using rule 32 (expr -> ID .)
    ASK             reduce using rule 32 (expr -> ID .)
    WHILE           reduce using rule 32 (expr -> ID .)
    SET             reduce using rule 32 (expr -> ID .)
    REPEAT          reduce using rule 32 (expr -> ID .)
    $end            reduce using rule 32 (expr -> ID .)
    END             reduce using rule 32 (expr -> ID .)
    THEN            reduce using rule 32 (expr -> ID .)
    TIMES           reduce using rule 32 (expr -> ID .)
    RPAREN          reduce using rule 32 (expr -> ID .)
    TO              reduce using rule 32 (expr -> ID .)
    DO              reduce using rule 32 (expr -> ID .)


state 24

    (33) expr -> LPAREN . expr RPAREN
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 48
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 25

    (34) expr -> RANDOM . NUMBER FROM expr TO expr

    NUMBER          shift and go to state 49


state 26

    (35) expr -> TEXT .

    PLUS            reduce using rule 35 (expr -> TEXT .)
    MINUS           reduce using rule 35 (expr -> TEXT .)
    MULTIPLY        reduce using rule 35 (expr -> TEXT .)
    DIVIDE          reduce using rule 35 (expr -> TEXT .)
    GT              reduce using rule 35 (expr -> TEXT .)
    LT              reduce using rule 35 (expr -> TEXT .)
    ET              reduce using rule 35 (expr -> TEXT .)
    GTE             reduce using rule 35 (expr -> TEXT .)
    LTE             reduce using rule 35 (expr -> TEXT .)
    NE              reduce using rule 35 (expr -> TEXT .)
    AND             reduce using rule 35 (expr -> TEXT .)
    OR              reduce using rule 35 (expr -> TEXT .)
    OUTPUT          reduce using rule 35 (expr -> TEXT .)
    IF              reduce using rule 35 (expr -> TEXT .)
    ASK             reduce using rule 35 (expr -> TEXT .)
    WHILE           reduce using rule 35 (expr -> TEXT .)
    SET             reduce using rule 35 (expr -> TEXT .)
    REPEAT          reduce using rule 35 (expr -> TEXT .)
    $end            reduce using rule 35 (expr -> TEXT .)
    END             reduce using rule 35 (expr -> TEXT .)
    THEN            reduce using rule 35 (expr -> TEXT .)
    TIMES           reduce using rule 35 (expr -> TEXT .)
    RPAREN          reduce using rule 35 (expr -> TEXT .)
    TO              reduce using rule 35 (expr -> TEXT .)
    DO              reduce using rule 35 (expr -> TEXT .)


state 27

    (36) expr -> CONVERT . expr TO datatype
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 50
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 28

    (12) if_then_stmt -> IF expr . THEN body END
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

    THEN            shift and go to state 51
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 29

    (13) input_stmt -> ASK expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

    OUTPUT          reduce using rule 13 (input_stmt -> ASK expr .)
    IF              reduce using rule 13 (input_stmt -> ASK expr .)
    ASK             reduce using rule 13 (input_stmt -> ASK expr .)
    WHILE           reduce using rule 13 (input_stmt -> ASK expr .)
    SET             reduce using rule 13 (input_stmt -> ASK expr .)
    REPEAT          reduce using rule 13 (input_stmt -> ASK expr .)
    $end            reduce using rule 13 (input_stmt -> ASK expr .)
    END             reduce using rule 13 (input_stmt -> ASK expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 30

    (14) while_stmt -> WHILE condition . DO body END
    (18) expr -> condition .

    DO              shift and go to state 52
    GT              reduce using rule 18 (expr -> condition .)
    LT              reduce using rule 18 (expr -> condition .)
    ET              reduce using rule 18 (expr -> condition .)
    GTE             reduce using rule 18 (expr -> condition .)
    LTE             reduce using rule 18 (expr -> condition .)
    NE              reduce using rule 18 (expr -> condition .)
    AND             reduce using rule 18 (expr -> condition .)
    OR              reduce using rule 18 (expr -> condition .)
    PLUS            reduce using rule 18 (expr -> condition .)
    MINUS           reduce using rule 18 (expr -> condition .)
    MULTIPLY        reduce using rule 18 (expr -> condition .)
    DIVIDE          reduce using rule 18 (expr -> condition .)


state 31

    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr

    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39


state 32

    (16) repeat_stmt -> repeat body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (10) set_stmt -> . var_stmt TO expr
    (11) output_stmt -> . OUTPUT expr
    (12) if_then_stmt -> . IF expr THEN body END
    (13) input_stmt -> . ASK expr
    (14) while_stmt -> . WHILE condition DO body END
    (16) repeat_stmt -> . repeat body END
    (9) var_stmt -> . SET ID
    (15) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 53
    OUTPUT          shift and go to state 10
    IF              shift and go to state 11
    ASK             shift and go to state 12
    WHILE           shift and go to state 13
    SET             shift and go to state 15
    REPEAT          shift and go to state 16

    repeat                         shift and go to state 14
    stmt                           shift and go to state 17
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    var_stmt                       shift and go to state 9

state 33

    (9) var_stmt -> SET ID .

    TO              reduce using rule 9 (var_stmt -> SET ID .)


state 34

    (15) repeat -> REPEAT expr . TIMES USING expr
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

    TIMES           shift and go to state 54
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 35

    (10) set_stmt -> var_stmt TO expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

    OUTPUT          reduce using rule 10 (set_stmt -> var_stmt TO expr .)
    IF              reduce using rule 10 (set_stmt -> var_stmt TO expr .)
    ASK             reduce using rule 10 (set_stmt -> var_stmt TO expr .)
    WHILE           reduce using rule 10 (set_stmt -> var_stmt TO expr .)
    SET             reduce using rule 10 (set_stmt -> var_stmt TO expr .)
    REPEAT          reduce using rule 10 (set_stmt -> var_stmt TO expr .)
    $end            reduce using rule 10 (set_stmt -> var_stmt TO expr .)
    END             reduce using rule 10 (set_stmt -> var_stmt TO expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 36

    (19) binop -> expr PLUS . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 55
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 37

    (20) binop -> expr MINUS . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 56
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 38

    (21) binop -> expr MULTIPLY . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 57
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 39

    (22) binop -> expr DIVIDE . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 58
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 40

    (23) condition -> expr GT . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 59
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 41

    (24) condition -> expr LT . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 60
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 42

    (25) condition -> expr ET . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 61
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 43

    (26) condition -> expr GTE . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 62
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 44

    (27) condition -> expr LTE . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 63
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 45

    (28) condition -> expr NE . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 64
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 46

    (29) condition -> expr AND . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 65
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 47

    (30) condition -> expr OR . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 66
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 48

    (33) expr -> LPAREN expr . RPAREN
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

    RPAREN          shift and go to state 67
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 49

    (34) expr -> RANDOM NUMBER . FROM expr TO expr

    FROM            shift and go to state 68


state 50

    (36) expr -> CONVERT expr . TO datatype
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

    TO              shift and go to state 69
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 51

    (12) if_then_stmt -> IF expr THEN . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (10) set_stmt -> . var_stmt TO expr
    (11) output_stmt -> . OUTPUT expr
    (12) if_then_stmt -> . IF expr THEN body END
    (13) input_stmt -> . ASK expr
    (14) while_stmt -> . WHILE condition DO body END
    (16) repeat_stmt -> . repeat body END
    (9) var_stmt -> . SET ID
    (15) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 10
    IF              shift and go to state 11
    ASK             shift and go to state 12
    WHILE           shift and go to state 13
    SET             shift and go to state 15
    REPEAT          shift and go to state 16

    body                           shift and go to state 70
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    var_stmt                       shift and go to state 9
    repeat                         shift and go to state 14

state 52

    (14) while_stmt -> WHILE condition DO . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (10) set_stmt -> . var_stmt TO expr
    (11) output_stmt -> . OUTPUT expr
    (12) if_then_stmt -> . IF expr THEN body END
    (13) input_stmt -> . ASK expr
    (14) while_stmt -> . WHILE condition DO body END
    (16) repeat_stmt -> . repeat body END
    (9) var_stmt -> . SET ID
    (15) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 10
    IF              shift and go to state 11
    ASK             shift and go to state 12
    WHILE           shift and go to state 13
    SET             shift and go to state 15
    REPEAT          shift and go to state 16

    body                           shift and go to state 71
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    var_stmt                       shift and go to state 9
    repeat                         shift and go to state 14

state 53

    (16) repeat_stmt -> repeat body END .

    OUTPUT          reduce using rule 16 (repeat_stmt -> repeat body END .)
    IF              reduce using rule 16 (repeat_stmt -> repeat body END .)
    ASK             reduce using rule 16 (repeat_stmt -> repeat body END .)
    WHILE           reduce using rule 16 (repeat_stmt -> repeat body END .)
    SET             reduce using rule 16 (repeat_stmt -> repeat body END .)
    REPEAT          reduce using rule 16 (repeat_stmt -> repeat body END .)
    $end            reduce using rule 16 (repeat_stmt -> repeat body END .)
    END             reduce using rule 16 (repeat_stmt -> repeat body END .)


state 54

    (15) repeat -> REPEAT expr TIMES . USING expr

    USING           shift and go to state 72


state 55

    (19) binop -> expr PLUS expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 19 (binop -> expr PLUS expr .)
    IF              reduce using rule 19 (binop -> expr PLUS expr .)
    ASK             reduce using rule 19 (binop -> expr PLUS expr .)
    WHILE           reduce using rule 19 (binop -> expr PLUS expr .)
    SET             reduce using rule 19 (binop -> expr PLUS expr .)
    REPEAT          reduce using rule 19 (binop -> expr PLUS expr .)
    $end            reduce using rule 19 (binop -> expr PLUS expr .)
    END             reduce using rule 19 (binop -> expr PLUS expr .)
    THEN            reduce using rule 19 (binop -> expr PLUS expr .)
    TIMES           reduce using rule 19 (binop -> expr PLUS expr .)
    RPAREN          reduce using rule 19 (binop -> expr PLUS expr .)
    TO              reduce using rule 19 (binop -> expr PLUS expr .)
    DO              reduce using rule 19 (binop -> expr PLUS expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! MINUS           [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! MULTIPLY        [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! GT              [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! LT              [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! ET              [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! GTE             [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! LTE             [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! NE              [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! AND             [ reduce using rule 19 (binop -> expr PLUS expr .) ]
  ! OR              [ reduce using rule 19 (binop -> expr PLUS expr .) ]


state 56

    (20) binop -> expr MINUS expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 20 (binop -> expr MINUS expr .)
    IF              reduce using rule 20 (binop -> expr MINUS expr .)
    ASK             reduce using rule 20 (binop -> expr MINUS expr .)
    WHILE           reduce using rule 20 (binop -> expr MINUS expr .)
    SET             reduce using rule 20 (binop -> expr MINUS expr .)
    REPEAT          reduce using rule 20 (binop -> expr MINUS expr .)
    $end            reduce using rule 20 (binop -> expr MINUS expr .)
    END             reduce using rule 20 (binop -> expr MINUS expr .)
    THEN            reduce using rule 20 (binop -> expr MINUS expr .)
    TIMES           reduce using rule 20 (binop -> expr MINUS expr .)
    RPAREN          reduce using rule 20 (binop -> expr MINUS expr .)
    TO              reduce using rule 20 (binop -> expr MINUS expr .)
    DO              reduce using rule 20 (binop -> expr MINUS expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! MINUS           [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! MULTIPLY        [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! GT              [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! LT              [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! ET              [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! GTE             [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! LTE             [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! NE              [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! AND             [ reduce using rule 20 (binop -> expr MINUS expr .) ]
  ! OR              [ reduce using rule 20 (binop -> expr MINUS expr .) ]


state 57

    (21) binop -> expr MULTIPLY expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 21 (binop -> expr MULTIPLY expr .)
    IF              reduce using rule 21 (binop -> expr MULTIPLY expr .)
    ASK             reduce using rule 21 (binop -> expr MULTIPLY expr .)
    WHILE           reduce using rule 21 (binop -> expr MULTIPLY expr .)
    SET             reduce using rule 21 (binop -> expr MULTIPLY expr .)
    REPEAT          reduce using rule 21 (binop -> expr MULTIPLY expr .)
    $end            reduce using rule 21 (binop -> expr MULTIPLY expr .)
    END             reduce using rule 21 (binop -> expr MULTIPLY expr .)
    THEN            reduce using rule 21 (binop -> expr MULTIPLY expr .)
    TIMES           reduce using rule 21 (binop -> expr MULTIPLY expr .)
    RPAREN          reduce using rule 21 (binop -> expr MULTIPLY expr .)
    TO              reduce using rule 21 (binop -> expr MULTIPLY expr .)
    DO              reduce using rule 21 (binop -> expr MULTIPLY expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! MINUS           [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! MULTIPLY        [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! DIVIDE          [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! GT              [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! LT              [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! ET              [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! GTE             [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! LTE             [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! NE              [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! AND             [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]
  ! OR              [ reduce using rule 21 (binop -> expr MULTIPLY expr .) ]


state 58

    (22) binop -> expr DIVIDE expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 22 (binop -> expr DIVIDE expr .)
    IF              reduce using rule 22 (binop -> expr DIVIDE expr .)
    ASK             reduce using rule 22 (binop -> expr DIVIDE expr .)
    WHILE           reduce using rule 22 (binop -> expr DIVIDE expr .)
    SET             reduce using rule 22 (binop -> expr DIVIDE expr .)
    REPEAT          reduce using rule 22 (binop -> expr DIVIDE expr .)
    $end            reduce using rule 22 (binop -> expr DIVIDE expr .)
    END             reduce using rule 22 (binop -> expr DIVIDE expr .)
    THEN            reduce using rule 22 (binop -> expr DIVIDE expr .)
    TIMES           reduce using rule 22 (binop -> expr DIVIDE expr .)
    RPAREN          reduce using rule 22 (binop -> expr DIVIDE expr .)
    TO              reduce using rule 22 (binop -> expr DIVIDE expr .)
    DO              reduce using rule 22 (binop -> expr DIVIDE expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! MINUS           [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! MULTIPLY        [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! DIVIDE          [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! GT              [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! LT              [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! ET              [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! GTE             [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! LTE             [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! NE              [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! AND             [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]
  ! OR              [ reduce using rule 22 (binop -> expr DIVIDE expr .) ]


state 59

    (23) condition -> expr GT expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 23 (condition -> expr GT expr .)
    IF              reduce using rule 23 (condition -> expr GT expr .)
    ASK             reduce using rule 23 (condition -> expr GT expr .)
    WHILE           reduce using rule 23 (condition -> expr GT expr .)
    SET             reduce using rule 23 (condition -> expr GT expr .)
    REPEAT          reduce using rule 23 (condition -> expr GT expr .)
    $end            reduce using rule 23 (condition -> expr GT expr .)
    END             reduce using rule 23 (condition -> expr GT expr .)
    THEN            reduce using rule 23 (condition -> expr GT expr .)
    DO              reduce using rule 23 (condition -> expr GT expr .)
    TIMES           reduce using rule 23 (condition -> expr GT expr .)
    RPAREN          reduce using rule 23 (condition -> expr GT expr .)
    TO              reduce using rule 23 (condition -> expr GT expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! MULTIPLY        [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! GT              [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! LT              [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! ET              [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! GTE             [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! LTE             [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! NE              [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! AND             [ reduce using rule 23 (condition -> expr GT expr .) ]
  ! OR              [ reduce using rule 23 (condition -> expr GT expr .) ]


state 60

    (24) condition -> expr LT expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 24 (condition -> expr LT expr .)
    IF              reduce using rule 24 (condition -> expr LT expr .)
    ASK             reduce using rule 24 (condition -> expr LT expr .)
    WHILE           reduce using rule 24 (condition -> expr LT expr .)
    SET             reduce using rule 24 (condition -> expr LT expr .)
    REPEAT          reduce using rule 24 (condition -> expr LT expr .)
    $end            reduce using rule 24 (condition -> expr LT expr .)
    END             reduce using rule 24 (condition -> expr LT expr .)
    THEN            reduce using rule 24 (condition -> expr LT expr .)
    DO              reduce using rule 24 (condition -> expr LT expr .)
    TIMES           reduce using rule 24 (condition -> expr LT expr .)
    RPAREN          reduce using rule 24 (condition -> expr LT expr .)
    TO              reduce using rule 24 (condition -> expr LT expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! MULTIPLY        [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! GT              [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! LT              [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! ET              [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! GTE             [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! LTE             [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! NE              [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! AND             [ reduce using rule 24 (condition -> expr LT expr .) ]
  ! OR              [ reduce using rule 24 (condition -> expr LT expr .) ]


state 61

    (25) condition -> expr ET expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 25 (condition -> expr ET expr .)
    IF              reduce using rule 25 (condition -> expr ET expr .)
    ASK             reduce using rule 25 (condition -> expr ET expr .)
    WHILE           reduce using rule 25 (condition -> expr ET expr .)
    SET             reduce using rule 25 (condition -> expr ET expr .)
    REPEAT          reduce using rule 25 (condition -> expr ET expr .)
    $end            reduce using rule 25 (condition -> expr ET expr .)
    END             reduce using rule 25 (condition -> expr ET expr .)
    THEN            reduce using rule 25 (condition -> expr ET expr .)
    DO              reduce using rule 25 (condition -> expr ET expr .)
    TIMES           reduce using rule 25 (condition -> expr ET expr .)
    RPAREN          reduce using rule 25 (condition -> expr ET expr .)
    TO              reduce using rule 25 (condition -> expr ET expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! MINUS           [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! MULTIPLY        [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! DIVIDE          [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! GT              [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! LT              [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! ET              [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! GTE             [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! LTE             [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! NE              [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! AND             [ reduce using rule 25 (condition -> expr ET expr .) ]
  ! OR              [ reduce using rule 25 (condition -> expr ET expr .) ]


state 62

    (26) condition -> expr GTE expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 26 (condition -> expr GTE expr .)
    IF              reduce using rule 26 (condition -> expr GTE expr .)
    ASK             reduce using rule 26 (condition -> expr GTE expr .)
    WHILE           reduce using rule 26 (condition -> expr GTE expr .)
    SET             reduce using rule 26 (condition -> expr GTE expr .)
    REPEAT          reduce using rule 26 (condition -> expr GTE expr .)
    $end            reduce using rule 26 (condition -> expr GTE expr .)
    END             reduce using rule 26 (condition -> expr GTE expr .)
    THEN            reduce using rule 26 (condition -> expr GTE expr .)
    DO              reduce using rule 26 (condition -> expr GTE expr .)
    TIMES           reduce using rule 26 (condition -> expr GTE expr .)
    RPAREN          reduce using rule 26 (condition -> expr GTE expr .)
    TO              reduce using rule 26 (condition -> expr GTE expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! MINUS           [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! MULTIPLY        [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! DIVIDE          [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! GT              [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! LT              [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! ET              [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! GTE             [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! LTE             [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! NE              [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! AND             [ reduce using rule 26 (condition -> expr GTE expr .) ]
  ! OR              [ reduce using rule 26 (condition -> expr GTE expr .) ]


state 63

    (27) condition -> expr LTE expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 27 (condition -> expr LTE expr .)
    IF              reduce using rule 27 (condition -> expr LTE expr .)
    ASK             reduce using rule 27 (condition -> expr LTE expr .)
    WHILE           reduce using rule 27 (condition -> expr LTE expr .)
    SET             reduce using rule 27 (condition -> expr LTE expr .)
    REPEAT          reduce using rule 27 (condition -> expr LTE expr .)
    $end            reduce using rule 27 (condition -> expr LTE expr .)
    END             reduce using rule 27 (condition -> expr LTE expr .)
    THEN            reduce using rule 27 (condition -> expr LTE expr .)
    DO              reduce using rule 27 (condition -> expr LTE expr .)
    TIMES           reduce using rule 27 (condition -> expr LTE expr .)
    RPAREN          reduce using rule 27 (condition -> expr LTE expr .)
    TO              reduce using rule 27 (condition -> expr LTE expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! MINUS           [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! MULTIPLY        [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! DIVIDE          [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! GT              [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! LT              [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! ET              [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! GTE             [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! LTE             [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! NE              [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! AND             [ reduce using rule 27 (condition -> expr LTE expr .) ]
  ! OR              [ reduce using rule 27 (condition -> expr LTE expr .) ]


state 64

    (28) condition -> expr NE expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 28 (condition -> expr NE expr .)
    IF              reduce using rule 28 (condition -> expr NE expr .)
    ASK             reduce using rule 28 (condition -> expr NE expr .)
    WHILE           reduce using rule 28 (condition -> expr NE expr .)
    SET             reduce using rule 28 (condition -> expr NE expr .)
    REPEAT          reduce using rule 28 (condition -> expr NE expr .)
    $end            reduce using rule 28 (condition -> expr NE expr .)
    END             reduce using rule 28 (condition -> expr NE expr .)
    THEN            reduce using rule 28 (condition -> expr NE expr .)
    DO              reduce using rule 28 (condition -> expr NE expr .)
    TIMES           reduce using rule 28 (condition -> expr NE expr .)
    RPAREN          reduce using rule 28 (condition -> expr NE expr .)
    TO              reduce using rule 28 (condition -> expr NE expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! MULTIPLY        [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! GT              [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! LT              [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! ET              [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! GTE             [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! LTE             [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! NE              [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! AND             [ reduce using rule 28 (condition -> expr NE expr .) ]
  ! OR              [ reduce using rule 28 (condition -> expr NE expr .) ]


state 65

    (29) condition -> expr AND expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 29 (condition -> expr AND expr .)
    IF              reduce using rule 29 (condition -> expr AND expr .)
    ASK             reduce using rule 29 (condition -> expr AND expr .)
    WHILE           reduce using rule 29 (condition -> expr AND expr .)
    SET             reduce using rule 29 (condition -> expr AND expr .)
    REPEAT          reduce using rule 29 (condition -> expr AND expr .)
    $end            reduce using rule 29 (condition -> expr AND expr .)
    END             reduce using rule 29 (condition -> expr AND expr .)
    THEN            reduce using rule 29 (condition -> expr AND expr .)
    DO              reduce using rule 29 (condition -> expr AND expr .)
    TIMES           reduce using rule 29 (condition -> expr AND expr .)
    RPAREN          reduce using rule 29 (condition -> expr AND expr .)
    TO              reduce using rule 29 (condition -> expr AND expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! MULTIPLY        [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! GT              [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! LT              [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! ET              [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! GTE             [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! LTE             [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! NE              [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! AND             [ reduce using rule 29 (condition -> expr AND expr .) ]
  ! OR              [ reduce using rule 29 (condition -> expr AND expr .) ]


state 66

    (30) condition -> expr OR expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 30 (condition -> expr OR expr .)
    IF              reduce using rule 30 (condition -> expr OR expr .)
    ASK             reduce using rule 30 (condition -> expr OR expr .)
    WHILE           reduce using rule 30 (condition -> expr OR expr .)
    SET             reduce using rule 30 (condition -> expr OR expr .)
    REPEAT          reduce using rule 30 (condition -> expr OR expr .)
    $end            reduce using rule 30 (condition -> expr OR expr .)
    END             reduce using rule 30 (condition -> expr OR expr .)
    THEN            reduce using rule 30 (condition -> expr OR expr .)
    DO              reduce using rule 30 (condition -> expr OR expr .)
    TIMES           reduce using rule 30 (condition -> expr OR expr .)
    RPAREN          reduce using rule 30 (condition -> expr OR expr .)
    TO              reduce using rule 30 (condition -> expr OR expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! MULTIPLY        [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! GT              [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! LT              [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! ET              [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! GTE             [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! LTE             [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! NE              [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! AND             [ reduce using rule 30 (condition -> expr OR expr .) ]
  ! OR              [ reduce using rule 30 (condition -> expr OR expr .) ]


state 67

    (33) expr -> LPAREN expr RPAREN .

    PLUS            reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    MULTIPLY        reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    ET              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    GTE             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    LTE             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    OUTPUT          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    IF              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    ASK             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    WHILE           reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    SET             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    REPEAT          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    END             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    THEN            reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    TO              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    DO              reduce using rule 33 (expr -> LPAREN expr RPAREN .)


state 68

    (34) expr -> RANDOM NUMBER FROM . expr TO expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 73
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 69

    (36) expr -> CONVERT expr TO . datatype
    (37) datatype -> . NUM
    (38) datatype -> . TXT

    NUM             shift and go to state 75
    TXT             shift and go to state 76

    datatype                       shift and go to state 74

state 70

    (12) if_then_stmt -> IF expr THEN body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (10) set_stmt -> . var_stmt TO expr
    (11) output_stmt -> . OUTPUT expr
    (12) if_then_stmt -> . IF expr THEN body END
    (13) input_stmt -> . ASK expr
    (14) while_stmt -> . WHILE condition DO body END
    (16) repeat_stmt -> . repeat body END
    (9) var_stmt -> . SET ID
    (15) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 77
    OUTPUT          shift and go to state 10
    IF              shift and go to state 11
    ASK             shift and go to state 12
    WHILE           shift and go to state 13
    SET             shift and go to state 15
    REPEAT          shift and go to state 16

    stmt                           shift and go to state 17
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    var_stmt                       shift and go to state 9
    repeat                         shift and go to state 14

state 71

    (14) while_stmt -> WHILE condition DO body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (10) set_stmt -> . var_stmt TO expr
    (11) output_stmt -> . OUTPUT expr
    (12) if_then_stmt -> . IF expr THEN body END
    (13) input_stmt -> . ASK expr
    (14) while_stmt -> . WHILE condition DO body END
    (16) repeat_stmt -> . repeat body END
    (9) var_stmt -> . SET ID
    (15) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 78
    OUTPUT          shift and go to state 10
    IF              shift and go to state 11
    ASK             shift and go to state 12
    WHILE           shift and go to state 13
    SET             shift and go to state 15
    REPEAT          shift and go to state 16

    stmt                           shift and go to state 17
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    var_stmt                       shift and go to state 9
    repeat                         shift and go to state 14

state 72

    (15) repeat -> REPEAT expr TIMES USING . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 79
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 73

    (34) expr -> RANDOM NUMBER FROM expr . TO expr
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

    TO              shift and go to state 80
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 74

    (36) expr -> CONVERT expr TO datatype .

    PLUS            reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    MINUS           reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    MULTIPLY        reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    DIVIDE          reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    GT              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    LT              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    ET              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    GTE             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    LTE             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    NE              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    AND             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    OR              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    OUTPUT          reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    IF              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    ASK             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    WHILE           reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    SET             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    REPEAT          reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    $end            reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    END             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    THEN            reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    TIMES           reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    RPAREN          reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    TO              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    DO              reduce using rule 36 (expr -> CONVERT expr TO datatype .)


state 75

    (37) datatype -> NUM .

    PLUS            reduce using rule 37 (datatype -> NUM .)
    MINUS           reduce using rule 37 (datatype -> NUM .)
    MULTIPLY        reduce using rule 37 (datatype -> NUM .)
    DIVIDE          reduce using rule 37 (datatype -> NUM .)
    GT              reduce using rule 37 (datatype -> NUM .)
    LT              reduce using rule 37 (datatype -> NUM .)
    ET              reduce using rule 37 (datatype -> NUM .)
    GTE             reduce using rule 37 (datatype -> NUM .)
    LTE             reduce using rule 37 (datatype -> NUM .)
    NE              reduce using rule 37 (datatype -> NUM .)
    AND             reduce using rule 37 (datatype -> NUM .)
    OR              reduce using rule 37 (datatype -> NUM .)
    OUTPUT          reduce using rule 37 (datatype -> NUM .)
    IF              reduce using rule 37 (datatype -> NUM .)
    ASK             reduce using rule 37 (datatype -> NUM .)
    WHILE           reduce using rule 37 (datatype -> NUM .)
    SET             reduce using rule 37 (datatype -> NUM .)
    REPEAT          reduce using rule 37 (datatype -> NUM .)
    $end            reduce using rule 37 (datatype -> NUM .)
    END             reduce using rule 37 (datatype -> NUM .)
    THEN            reduce using rule 37 (datatype -> NUM .)
    TIMES           reduce using rule 37 (datatype -> NUM .)
    RPAREN          reduce using rule 37 (datatype -> NUM .)
    TO              reduce using rule 37 (datatype -> NUM .)
    DO              reduce using rule 37 (datatype -> NUM .)


state 76

    (38) datatype -> TXT .

    PLUS            reduce using rule 38 (datatype -> TXT .)
    MINUS           reduce using rule 38 (datatype -> TXT .)
    MULTIPLY        reduce using rule 38 (datatype -> TXT .)
    DIVIDE          reduce using rule 38 (datatype -> TXT .)
    GT              reduce using rule 38 (datatype -> TXT .)
    LT              reduce using rule 38 (datatype -> TXT .)
    ET              reduce using rule 38 (datatype -> TXT .)
    GTE             reduce using rule 38 (datatype -> TXT .)
    LTE             reduce using rule 38 (datatype -> TXT .)
    NE              reduce using rule 38 (datatype -> TXT .)
    AND             reduce using rule 38 (datatype -> TXT .)
    OR              reduce using rule 38 (datatype -> TXT .)
    OUTPUT          reduce using rule 38 (datatype -> TXT .)
    IF              reduce using rule 38 (datatype -> TXT .)
    ASK             reduce using rule 38 (datatype -> TXT .)
    WHILE           reduce using rule 38 (datatype -> TXT .)
    SET             reduce using rule 38 (datatype -> TXT .)
    REPEAT          reduce using rule 38 (datatype -> TXT .)
    $end            reduce using rule 38 (datatype -> TXT .)
    END             reduce using rule 38 (datatype -> TXT .)
    THEN            reduce using rule 38 (datatype -> TXT .)
    TIMES           reduce using rule 38 (datatype -> TXT .)
    RPAREN          reduce using rule 38 (datatype -> TXT .)
    TO              reduce using rule 38 (datatype -> TXT .)
    DO              reduce using rule 38 (datatype -> TXT .)


state 77

    (12) if_then_stmt -> IF expr THEN body END .

    OUTPUT          reduce using rule 12 (if_then_stmt -> IF expr THEN body END .)
    IF              reduce using rule 12 (if_then_stmt -> IF expr THEN body END .)
    ASK             reduce using rule 12 (if_then_stmt -> IF expr THEN body END .)
    WHILE           reduce using rule 12 (if_then_stmt -> IF expr THEN body END .)
    SET             reduce using rule 12 (if_then_stmt -> IF expr THEN body END .)
    REPEAT          reduce using rule 12 (if_then_stmt -> IF expr THEN body END .)
    $end            reduce using rule 12 (if_then_stmt -> IF expr THEN body END .)
    END             reduce using rule 12 (if_then_stmt -> IF expr THEN body END .)


state 78

    (14) while_stmt -> WHILE condition DO body END .

    OUTPUT          reduce using rule 14 (while_stmt -> WHILE condition DO body END .)
    IF              reduce using rule 14 (while_stmt -> WHILE condition DO body END .)
    ASK             reduce using rule 14 (while_stmt -> WHILE condition DO body END .)
    WHILE           reduce using rule 14 (while_stmt -> WHILE condition DO body END .)
    SET             reduce using rule 14 (while_stmt -> WHILE condition DO body END .)
    REPEAT          reduce using rule 14 (while_stmt -> WHILE condition DO body END .)
    $end            reduce using rule 14 (while_stmt -> WHILE condition DO body END .)
    END             reduce using rule 14 (while_stmt -> WHILE condition DO body END .)


state 79

    (15) repeat -> REPEAT expr TIMES USING expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

    OUTPUT          reduce using rule 15 (repeat -> REPEAT expr TIMES USING expr .)
    IF              reduce using rule 15 (repeat -> REPEAT expr TIMES USING expr .)
    ASK             reduce using rule 15 (repeat -> REPEAT expr TIMES USING expr .)
    WHILE           reduce using rule 15 (repeat -> REPEAT expr TIMES USING expr .)
    SET             reduce using rule 15 (repeat -> REPEAT expr TIMES USING expr .)
    REPEAT          reduce using rule 15 (repeat -> REPEAT expr TIMES USING expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47


state 80

    (34) expr -> RANDOM NUMBER FROM expr TO . expr
    (17) expr -> . binop
    (18) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (19) binop -> . expr PLUS expr
    (20) binop -> . expr MINUS expr
    (21) binop -> . expr MULTIPLY expr
    (22) binop -> . expr DIVIDE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LT expr
    (25) condition -> . expr ET expr
    (26) condition -> . expr GTE expr
    (27) condition -> . expr LTE expr
    (28) condition -> . expr NE expr
    (29) condition -> . expr AND expr
    (30) condition -> . expr OR expr

    DIGIT           shift and go to state 22
    ID              shift and go to state 23
    LPAREN          shift and go to state 24
    RANDOM          shift and go to state 25
    TEXT            shift and go to state 26
    CONVERT         shift and go to state 27

    expr                           shift and go to state 81
    binop                          shift and go to state 20
    condition                      shift and go to state 21

state 81

    (34) expr -> RANDOM NUMBER FROM expr TO expr .
    (19) binop -> expr . PLUS expr
    (20) binop -> expr . MINUS expr
    (21) binop -> expr . MULTIPLY expr
    (22) binop -> expr . DIVIDE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LT expr
    (25) condition -> expr . ET expr
    (26) condition -> expr . GTE expr
    (27) condition -> expr . LTE expr
    (28) condition -> expr . NE expr
    (29) condition -> expr . AND expr
    (30) condition -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    OUTPUT          reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    IF              reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    ASK             reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    WHILE           reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    SET             reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    REPEAT          reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    $end            reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    END             reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    THEN            reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    TIMES           reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    RPAREN          reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    TO              reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    DO              reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    MULTIPLY        shift and go to state 38
    DIVIDE          shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    ET              shift and go to state 42
    GTE             shift and go to state 43
    LTE             shift and go to state 44
    NE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47

  ! PLUS            [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! MINUS           [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! MULTIPLY        [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! DIVIDE          [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! GT              [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! LT              [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! ET              [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! GTE             [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! LTE             [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! NE              [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! AND             [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! OR              [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 55 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 55 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 55 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 55 resolved as shift
WARNING: shift/reduce conflict for GT in state 55 resolved as shift
WARNING: shift/reduce conflict for LT in state 55 resolved as shift
WARNING: shift/reduce conflict for ET in state 55 resolved as shift
WARNING: shift/reduce conflict for GTE in state 55 resolved as shift
WARNING: shift/reduce conflict for LTE in state 55 resolved as shift
WARNING: shift/reduce conflict for NE in state 55 resolved as shift
WARNING: shift/reduce conflict for AND in state 55 resolved as shift
WARNING: shift/reduce conflict for OR in state 55 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 56 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 56 resolved as shift
WARNING: shift/reduce conflict for GT in state 56 resolved as shift
WARNING: shift/reduce conflict for LT in state 56 resolved as shift
WARNING: shift/reduce conflict for ET in state 56 resolved as shift
WARNING: shift/reduce conflict for GTE in state 56 resolved as shift
WARNING: shift/reduce conflict for LTE in state 56 resolved as shift
WARNING: shift/reduce conflict for NE in state 56 resolved as shift
WARNING: shift/reduce conflict for AND in state 56 resolved as shift
WARNING: shift/reduce conflict for OR in state 56 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 57 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 57 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 57 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 57 resolved as shift
WARNING: shift/reduce conflict for GT in state 57 resolved as shift
WARNING: shift/reduce conflict for LT in state 57 resolved as shift
WARNING: shift/reduce conflict for ET in state 57 resolved as shift
WARNING: shift/reduce conflict for GTE in state 57 resolved as shift
WARNING: shift/reduce conflict for LTE in state 57 resolved as shift
WARNING: shift/reduce conflict for NE in state 57 resolved as shift
WARNING: shift/reduce conflict for AND in state 57 resolved as shift
WARNING: shift/reduce conflict for OR in state 57 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 58 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 58 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 58 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 58 resolved as shift
WARNING: shift/reduce conflict for GT in state 58 resolved as shift
WARNING: shift/reduce conflict for LT in state 58 resolved as shift
WARNING: shift/reduce conflict for ET in state 58 resolved as shift
WARNING: shift/reduce conflict for GTE in state 58 resolved as shift
WARNING: shift/reduce conflict for LTE in state 58 resolved as shift
WARNING: shift/reduce conflict for NE in state 58 resolved as shift
WARNING: shift/reduce conflict for AND in state 58 resolved as shift
WARNING: shift/reduce conflict for OR in state 58 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 59 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 59 resolved as shift
WARNING: shift/reduce conflict for GT in state 59 resolved as shift
WARNING: shift/reduce conflict for LT in state 59 resolved as shift
WARNING: shift/reduce conflict for ET in state 59 resolved as shift
WARNING: shift/reduce conflict for GTE in state 59 resolved as shift
WARNING: shift/reduce conflict for LTE in state 59 resolved as shift
WARNING: shift/reduce conflict for NE in state 59 resolved as shift
WARNING: shift/reduce conflict for AND in state 59 resolved as shift
WARNING: shift/reduce conflict for OR in state 59 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 60 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 60 resolved as shift
WARNING: shift/reduce conflict for GT in state 60 resolved as shift
WARNING: shift/reduce conflict for LT in state 60 resolved as shift
WARNING: shift/reduce conflict for ET in state 60 resolved as shift
WARNING: shift/reduce conflict for GTE in state 60 resolved as shift
WARNING: shift/reduce conflict for LTE in state 60 resolved as shift
WARNING: shift/reduce conflict for NE in state 60 resolved as shift
WARNING: shift/reduce conflict for AND in state 60 resolved as shift
WARNING: shift/reduce conflict for OR in state 60 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 61 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 61 resolved as shift
WARNING: shift/reduce conflict for GT in state 61 resolved as shift
WARNING: shift/reduce conflict for LT in state 61 resolved as shift
WARNING: shift/reduce conflict for ET in state 61 resolved as shift
WARNING: shift/reduce conflict for GTE in state 61 resolved as shift
WARNING: shift/reduce conflict for LTE in state 61 resolved as shift
WARNING: shift/reduce conflict for NE in state 61 resolved as shift
WARNING: shift/reduce conflict for AND in state 61 resolved as shift
WARNING: shift/reduce conflict for OR in state 61 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 62 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 62 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 62 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 62 resolved as shift
WARNING: shift/reduce conflict for GT in state 62 resolved as shift
WARNING: shift/reduce conflict for LT in state 62 resolved as shift
WARNING: shift/reduce conflict for ET in state 62 resolved as shift
WARNING: shift/reduce conflict for GTE in state 62 resolved as shift
WARNING: shift/reduce conflict for LTE in state 62 resolved as shift
WARNING: shift/reduce conflict for NE in state 62 resolved as shift
WARNING: shift/reduce conflict for AND in state 62 resolved as shift
WARNING: shift/reduce conflict for OR in state 62 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 63 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 63 resolved as shift
WARNING: shift/reduce conflict for GT in state 63 resolved as shift
WARNING: shift/reduce conflict for LT in state 63 resolved as shift
WARNING: shift/reduce conflict for ET in state 63 resolved as shift
WARNING: shift/reduce conflict for GTE in state 63 resolved as shift
WARNING: shift/reduce conflict for LTE in state 63 resolved as shift
WARNING: shift/reduce conflict for NE in state 63 resolved as shift
WARNING: shift/reduce conflict for AND in state 63 resolved as shift
WARNING: shift/reduce conflict for OR in state 63 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 64 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 64 resolved as shift
WARNING: shift/reduce conflict for GT in state 64 resolved as shift
WARNING: shift/reduce conflict for LT in state 64 resolved as shift
WARNING: shift/reduce conflict for ET in state 64 resolved as shift
WARNING: shift/reduce conflict for GTE in state 64 resolved as shift
WARNING: shift/reduce conflict for LTE in state 64 resolved as shift
WARNING: shift/reduce conflict for NE in state 64 resolved as shift
WARNING: shift/reduce conflict for AND in state 64 resolved as shift
WARNING: shift/reduce conflict for OR in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 65 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 65 resolved as shift
WARNING: shift/reduce conflict for GT in state 65 resolved as shift
WARNING: shift/reduce conflict for LT in state 65 resolved as shift
WARNING: shift/reduce conflict for ET in state 65 resolved as shift
WARNING: shift/reduce conflict for GTE in state 65 resolved as shift
WARNING: shift/reduce conflict for LTE in state 65 resolved as shift
WARNING: shift/reduce conflict for NE in state 65 resolved as shift
WARNING: shift/reduce conflict for AND in state 65 resolved as shift
WARNING: shift/reduce conflict for OR in state 65 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 66 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 66 resolved as shift
WARNING: shift/reduce conflict for GT in state 66 resolved as shift
WARNING: shift/reduce conflict for LT in state 66 resolved as shift
WARNING: shift/reduce conflict for ET in state 66 resolved as shift
WARNING: shift/reduce conflict for GTE in state 66 resolved as shift
WARNING: shift/reduce conflict for LTE in state 66 resolved as shift
WARNING: shift/reduce conflict for NE in state 66 resolved as shift
WARNING: shift/reduce conflict for AND in state 66 resolved as shift
WARNING: shift/reduce conflict for OR in state 66 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 81 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for GT in state 81 resolved as shift
WARNING: shift/reduce conflict for LT in state 81 resolved as shift
WARNING: shift/reduce conflict for ET in state 81 resolved as shift
WARNING: shift/reduce conflict for GTE in state 81 resolved as shift
WARNING: shift/reduce conflict for LTE in state 81 resolved as shift
WARNING: shift/reduce conflict for NE in state 81 resolved as shift
WARNING: shift/reduce conflict for AND in state 81 resolved as shift
WARNING: shift/reduce conflict for OR in state 81 resolved as shift
