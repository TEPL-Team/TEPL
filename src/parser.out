Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> body
Rule 1     body -> stmt
Rule 2     body -> body stmt
Rule 3     stmt -> set_stmt
Rule 4     stmt -> output_stmt
Rule 5     stmt -> if_then_stmt
Rule 6     stmt -> input_stmt
Rule 7     stmt -> while_stmt
Rule 8     stmt -> repeat_stmt
Rule 9     stmt -> pause_stmt
Rule 10    stmt -> forever_stmt
Rule 11    stmt -> exit_stmt
Rule 12    var_stmt -> SET ID
Rule 13    set_stmt -> var_stmt TO expr
Rule 14    output_stmt -> OUTPUT expr
Rule 15    if_then_stmt -> IF expr THEN body END
Rule 16    input_stmt -> ASK expr
Rule 17    while_stmt -> WHILE condition DO body END
Rule 18    repeat -> REPEAT expr TIMES USING expr
Rule 19    repeat_stmt -> repeat body END
Rule 20    pause_stmt -> PAUSE expr
Rule 21    forever_stmt -> FOREVER DO body END
Rule 22    exit_stmt -> EXIT LOOP
Rule 23    expr -> binop
Rule 24    expr -> condition
Rule 25    binop -> expr PLUS expr
Rule 26    binop -> expr MINUS expr
Rule 27    binop -> expr MULTIPLY expr
Rule 28    binop -> expr DIVIDE expr
Rule 29    condition -> expr GT expr
Rule 30    condition -> expr LT expr
Rule 31    condition -> expr ET expr
Rule 32    condition -> expr GTE expr
Rule 33    condition -> expr LTE expr
Rule 34    condition -> expr NE expr
Rule 35    expr -> DIGIT
Rule 36    expr -> ID
Rule 37    expr -> LPAREN expr RPAREN
Rule 38    expr -> RANDOM NUMBER FROM expr TO expr
Rule 39    expr -> TEXT
Rule 40    expr -> CONVERT expr TO datatype
Rule 41    datatype -> NUM
Rule 42    datatype -> TXT

Terminals, with rules where they appear

ASK                  : 16
COMMENT              : 
CONVERT              : 40
DIGIT                : 35
DIVIDE               : 28
DO                   : 17 21
END                  : 15 17 19 21
ET                   : 31
EXIT                 : 22
FOREVER              : 21
FROM                 : 38
GT                   : 29
GTE                  : 32
ID                   : 12 36
IF                   : 15
LOOP                 : 22
LPAREN               : 37
LT                   : 30
LTE                  : 33
MINUS                : 26
MULTIPLY             : 27
NE                   : 34
NUM                  : 41
NUMBER               : 38
OUTPUT               : 14
PAUSE                : 20
PLUS                 : 25
RANDOM               : 38
REPEAT               : 18
RPAREN               : 37
SET                  : 12
TEXT                 : 39
THEN                 : 15
TIMES                : 18
TO                   : 13 38 40
TXT                  : 42
USING                : 18
WHILE                : 17
error                : 

Nonterminals, with rules where they appear

binop                : 23
body                 : 2 15 17 19 21 0
condition            : 17 24
datatype             : 40
exit_stmt            : 11
expr                 : 13 14 15 16 18 18 20 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 37 38 38 40
forever_stmt         : 10
if_then_stmt         : 5
input_stmt           : 6
output_stmt          : 4
pause_stmt           : 9
repeat               : 19
repeat_stmt          : 8
set_stmt             : 3
stmt                 : 1 2
var_stmt             : 13
while_stmt           : 7

Parsing method: LALR

state 0

    (0) S' -> . body
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (13) set_stmt -> . var_stmt TO expr
    (14) output_stmt -> . OUTPUT expr
    (15) if_then_stmt -> . IF expr THEN body END
    (16) input_stmt -> . ASK expr
    (17) while_stmt -> . WHILE condition DO body END
    (19) repeat_stmt -> . repeat body END
    (20) pause_stmt -> . PAUSE expr
    (21) forever_stmt -> . FOREVER DO body END
    (22) exit_stmt -> . EXIT LOOP
    (12) var_stmt -> . SET ID
    (18) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 13
    IF              shift and go to state 14
    ASK             shift and go to state 15
    WHILE           shift and go to state 16
    PAUSE           shift and go to state 18
    FOREVER         shift and go to state 19
    EXIT            shift and go to state 20
    SET             shift and go to state 21
    REPEAT          shift and go to state 22

    body                           shift and go to state 1
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    var_stmt                       shift and go to state 12
    repeat                         shift and go to state 17

state 1

    (0) S' -> body .
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (13) set_stmt -> . var_stmt TO expr
    (14) output_stmt -> . OUTPUT expr
    (15) if_then_stmt -> . IF expr THEN body END
    (16) input_stmt -> . ASK expr
    (17) while_stmt -> . WHILE condition DO body END
    (19) repeat_stmt -> . repeat body END
    (20) pause_stmt -> . PAUSE expr
    (21) forever_stmt -> . FOREVER DO body END
    (22) exit_stmt -> . EXIT LOOP
    (12) var_stmt -> . SET ID
    (18) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 13
    IF              shift and go to state 14
    ASK             shift and go to state 15
    WHILE           shift and go to state 16
    PAUSE           shift and go to state 18
    FOREVER         shift and go to state 19
    EXIT            shift and go to state 20
    SET             shift and go to state 21
    REPEAT          shift and go to state 22

    stmt                           shift and go to state 23
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    var_stmt                       shift and go to state 12
    repeat                         shift and go to state 17

state 2

    (1) body -> stmt .

    OUTPUT          reduce using rule 1 (body -> stmt .)
    IF              reduce using rule 1 (body -> stmt .)
    ASK             reduce using rule 1 (body -> stmt .)
    WHILE           reduce using rule 1 (body -> stmt .)
    PAUSE           reduce using rule 1 (body -> stmt .)
    FOREVER         reduce using rule 1 (body -> stmt .)
    EXIT            reduce using rule 1 (body -> stmt .)
    SET             reduce using rule 1 (body -> stmt .)
    REPEAT          reduce using rule 1 (body -> stmt .)
    $end            reduce using rule 1 (body -> stmt .)
    END             reduce using rule 1 (body -> stmt .)


state 3

    (3) stmt -> set_stmt .

    OUTPUT          reduce using rule 3 (stmt -> set_stmt .)
    IF              reduce using rule 3 (stmt -> set_stmt .)
    ASK             reduce using rule 3 (stmt -> set_stmt .)
    WHILE           reduce using rule 3 (stmt -> set_stmt .)
    PAUSE           reduce using rule 3 (stmt -> set_stmt .)
    FOREVER         reduce using rule 3 (stmt -> set_stmt .)
    EXIT            reduce using rule 3 (stmt -> set_stmt .)
    SET             reduce using rule 3 (stmt -> set_stmt .)
    REPEAT          reduce using rule 3 (stmt -> set_stmt .)
    $end            reduce using rule 3 (stmt -> set_stmt .)
    END             reduce using rule 3 (stmt -> set_stmt .)


state 4

    (4) stmt -> output_stmt .

    OUTPUT          reduce using rule 4 (stmt -> output_stmt .)
    IF              reduce using rule 4 (stmt -> output_stmt .)
    ASK             reduce using rule 4 (stmt -> output_stmt .)
    WHILE           reduce using rule 4 (stmt -> output_stmt .)
    PAUSE           reduce using rule 4 (stmt -> output_stmt .)
    FOREVER         reduce using rule 4 (stmt -> output_stmt .)
    EXIT            reduce using rule 4 (stmt -> output_stmt .)
    SET             reduce using rule 4 (stmt -> output_stmt .)
    REPEAT          reduce using rule 4 (stmt -> output_stmt .)
    $end            reduce using rule 4 (stmt -> output_stmt .)
    END             reduce using rule 4 (stmt -> output_stmt .)


state 5

    (5) stmt -> if_then_stmt .

    OUTPUT          reduce using rule 5 (stmt -> if_then_stmt .)
    IF              reduce using rule 5 (stmt -> if_then_stmt .)
    ASK             reduce using rule 5 (stmt -> if_then_stmt .)
    WHILE           reduce using rule 5 (stmt -> if_then_stmt .)
    PAUSE           reduce using rule 5 (stmt -> if_then_stmt .)
    FOREVER         reduce using rule 5 (stmt -> if_then_stmt .)
    EXIT            reduce using rule 5 (stmt -> if_then_stmt .)
    SET             reduce using rule 5 (stmt -> if_then_stmt .)
    REPEAT          reduce using rule 5 (stmt -> if_then_stmt .)
    $end            reduce using rule 5 (stmt -> if_then_stmt .)
    END             reduce using rule 5 (stmt -> if_then_stmt .)


state 6

    (6) stmt -> input_stmt .

    OUTPUT          reduce using rule 6 (stmt -> input_stmt .)
    IF              reduce using rule 6 (stmt -> input_stmt .)
    ASK             reduce using rule 6 (stmt -> input_stmt .)
    WHILE           reduce using rule 6 (stmt -> input_stmt .)
    PAUSE           reduce using rule 6 (stmt -> input_stmt .)
    FOREVER         reduce using rule 6 (stmt -> input_stmt .)
    EXIT            reduce using rule 6 (stmt -> input_stmt .)
    SET             reduce using rule 6 (stmt -> input_stmt .)
    REPEAT          reduce using rule 6 (stmt -> input_stmt .)
    $end            reduce using rule 6 (stmt -> input_stmt .)
    END             reduce using rule 6 (stmt -> input_stmt .)


state 7

    (7) stmt -> while_stmt .

    OUTPUT          reduce using rule 7 (stmt -> while_stmt .)
    IF              reduce using rule 7 (stmt -> while_stmt .)
    ASK             reduce using rule 7 (stmt -> while_stmt .)
    WHILE           reduce using rule 7 (stmt -> while_stmt .)
    PAUSE           reduce using rule 7 (stmt -> while_stmt .)
    FOREVER         reduce using rule 7 (stmt -> while_stmt .)
    EXIT            reduce using rule 7 (stmt -> while_stmt .)
    SET             reduce using rule 7 (stmt -> while_stmt .)
    REPEAT          reduce using rule 7 (stmt -> while_stmt .)
    $end            reduce using rule 7 (stmt -> while_stmt .)
    END             reduce using rule 7 (stmt -> while_stmt .)


state 8

    (8) stmt -> repeat_stmt .

    OUTPUT          reduce using rule 8 (stmt -> repeat_stmt .)
    IF              reduce using rule 8 (stmt -> repeat_stmt .)
    ASK             reduce using rule 8 (stmt -> repeat_stmt .)
    WHILE           reduce using rule 8 (stmt -> repeat_stmt .)
    PAUSE           reduce using rule 8 (stmt -> repeat_stmt .)
    FOREVER         reduce using rule 8 (stmt -> repeat_stmt .)
    EXIT            reduce using rule 8 (stmt -> repeat_stmt .)
    SET             reduce using rule 8 (stmt -> repeat_stmt .)
    REPEAT          reduce using rule 8 (stmt -> repeat_stmt .)
    $end            reduce using rule 8 (stmt -> repeat_stmt .)
    END             reduce using rule 8 (stmt -> repeat_stmt .)


state 9

    (9) stmt -> pause_stmt .

    OUTPUT          reduce using rule 9 (stmt -> pause_stmt .)
    IF              reduce using rule 9 (stmt -> pause_stmt .)
    ASK             reduce using rule 9 (stmt -> pause_stmt .)
    WHILE           reduce using rule 9 (stmt -> pause_stmt .)
    PAUSE           reduce using rule 9 (stmt -> pause_stmt .)
    FOREVER         reduce using rule 9 (stmt -> pause_stmt .)
    EXIT            reduce using rule 9 (stmt -> pause_stmt .)
    SET             reduce using rule 9 (stmt -> pause_stmt .)
    REPEAT          reduce using rule 9 (stmt -> pause_stmt .)
    $end            reduce using rule 9 (stmt -> pause_stmt .)
    END             reduce using rule 9 (stmt -> pause_stmt .)


state 10

    (10) stmt -> forever_stmt .

    OUTPUT          reduce using rule 10 (stmt -> forever_stmt .)
    IF              reduce using rule 10 (stmt -> forever_stmt .)
    ASK             reduce using rule 10 (stmt -> forever_stmt .)
    WHILE           reduce using rule 10 (stmt -> forever_stmt .)
    PAUSE           reduce using rule 10 (stmt -> forever_stmt .)
    FOREVER         reduce using rule 10 (stmt -> forever_stmt .)
    EXIT            reduce using rule 10 (stmt -> forever_stmt .)
    SET             reduce using rule 10 (stmt -> forever_stmt .)
    REPEAT          reduce using rule 10 (stmt -> forever_stmt .)
    $end            reduce using rule 10 (stmt -> forever_stmt .)
    END             reduce using rule 10 (stmt -> forever_stmt .)


state 11

    (11) stmt -> exit_stmt .

    OUTPUT          reduce using rule 11 (stmt -> exit_stmt .)
    IF              reduce using rule 11 (stmt -> exit_stmt .)
    ASK             reduce using rule 11 (stmt -> exit_stmt .)
    WHILE           reduce using rule 11 (stmt -> exit_stmt .)
    PAUSE           reduce using rule 11 (stmt -> exit_stmt .)
    FOREVER         reduce using rule 11 (stmt -> exit_stmt .)
    EXIT            reduce using rule 11 (stmt -> exit_stmt .)
    SET             reduce using rule 11 (stmt -> exit_stmt .)
    REPEAT          reduce using rule 11 (stmt -> exit_stmt .)
    $end            reduce using rule 11 (stmt -> exit_stmt .)
    END             reduce using rule 11 (stmt -> exit_stmt .)


state 12

    (13) set_stmt -> var_stmt . TO expr

    TO              shift and go to state 24


state 13

    (14) output_stmt -> OUTPUT . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 25
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 14

    (15) if_then_stmt -> IF . expr THEN body END
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 34
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 15

    (16) input_stmt -> ASK . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 35
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 16

    (17) while_stmt -> WHILE . condition DO body END
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    condition                      shift and go to state 36
    expr                           shift and go to state 37
    binop                          shift and go to state 26

state 17

    (19) repeat_stmt -> repeat . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (13) set_stmt -> . var_stmt TO expr
    (14) output_stmt -> . OUTPUT expr
    (15) if_then_stmt -> . IF expr THEN body END
    (16) input_stmt -> . ASK expr
    (17) while_stmt -> . WHILE condition DO body END
    (19) repeat_stmt -> . repeat body END
    (20) pause_stmt -> . PAUSE expr
    (21) forever_stmt -> . FOREVER DO body END
    (22) exit_stmt -> . EXIT LOOP
    (12) var_stmt -> . SET ID
    (18) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 13
    IF              shift and go to state 14
    ASK             shift and go to state 15
    WHILE           shift and go to state 16
    PAUSE           shift and go to state 18
    FOREVER         shift and go to state 19
    EXIT            shift and go to state 20
    SET             shift and go to state 21
    REPEAT          shift and go to state 22

    repeat                         shift and go to state 17
    body                           shift and go to state 38
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    var_stmt                       shift and go to state 12

state 18

    (20) pause_stmt -> PAUSE . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 39
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 19

    (21) forever_stmt -> FOREVER . DO body END

    DO              shift and go to state 40


state 20

    (22) exit_stmt -> EXIT . LOOP

    LOOP            shift and go to state 41


state 21

    (12) var_stmt -> SET . ID

    ID              shift and go to state 42


state 22

    (18) repeat -> REPEAT . expr TIMES USING expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 43
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 23

    (2) body -> body stmt .

    OUTPUT          reduce using rule 2 (body -> body stmt .)
    IF              reduce using rule 2 (body -> body stmt .)
    ASK             reduce using rule 2 (body -> body stmt .)
    WHILE           reduce using rule 2 (body -> body stmt .)
    PAUSE           reduce using rule 2 (body -> body stmt .)
    FOREVER         reduce using rule 2 (body -> body stmt .)
    EXIT            reduce using rule 2 (body -> body stmt .)
    SET             reduce using rule 2 (body -> body stmt .)
    REPEAT          reduce using rule 2 (body -> body stmt .)
    $end            reduce using rule 2 (body -> body stmt .)
    END             reduce using rule 2 (body -> body stmt .)


state 24

    (13) set_stmt -> var_stmt TO . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 44
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 25

    (14) output_stmt -> OUTPUT expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

    OUTPUT          reduce using rule 14 (output_stmt -> OUTPUT expr .)
    IF              reduce using rule 14 (output_stmt -> OUTPUT expr .)
    ASK             reduce using rule 14 (output_stmt -> OUTPUT expr .)
    WHILE           reduce using rule 14 (output_stmt -> OUTPUT expr .)
    PAUSE           reduce using rule 14 (output_stmt -> OUTPUT expr .)
    FOREVER         reduce using rule 14 (output_stmt -> OUTPUT expr .)
    EXIT            reduce using rule 14 (output_stmt -> OUTPUT expr .)
    SET             reduce using rule 14 (output_stmt -> OUTPUT expr .)
    REPEAT          reduce using rule 14 (output_stmt -> OUTPUT expr .)
    $end            reduce using rule 14 (output_stmt -> OUTPUT expr .)
    END             reduce using rule 14 (output_stmt -> OUTPUT expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54


state 26

    (23) expr -> binop .

    PLUS            reduce using rule 23 (expr -> binop .)
    MINUS           reduce using rule 23 (expr -> binop .)
    MULTIPLY        reduce using rule 23 (expr -> binop .)
    DIVIDE          reduce using rule 23 (expr -> binop .)
    GT              reduce using rule 23 (expr -> binop .)
    LT              reduce using rule 23 (expr -> binop .)
    ET              reduce using rule 23 (expr -> binop .)
    GTE             reduce using rule 23 (expr -> binop .)
    LTE             reduce using rule 23 (expr -> binop .)
    NE              reduce using rule 23 (expr -> binop .)
    OUTPUT          reduce using rule 23 (expr -> binop .)
    IF              reduce using rule 23 (expr -> binop .)
    ASK             reduce using rule 23 (expr -> binop .)
    WHILE           reduce using rule 23 (expr -> binop .)
    PAUSE           reduce using rule 23 (expr -> binop .)
    FOREVER         reduce using rule 23 (expr -> binop .)
    EXIT            reduce using rule 23 (expr -> binop .)
    SET             reduce using rule 23 (expr -> binop .)
    REPEAT          reduce using rule 23 (expr -> binop .)
    $end            reduce using rule 23 (expr -> binop .)
    END             reduce using rule 23 (expr -> binop .)
    THEN            reduce using rule 23 (expr -> binop .)
    TIMES           reduce using rule 23 (expr -> binop .)
    RPAREN          reduce using rule 23 (expr -> binop .)
    TO              reduce using rule 23 (expr -> binop .)
    DO              reduce using rule 23 (expr -> binop .)


state 27

    (24) expr -> condition .

    PLUS            reduce using rule 24 (expr -> condition .)
    MINUS           reduce using rule 24 (expr -> condition .)
    MULTIPLY        reduce using rule 24 (expr -> condition .)
    DIVIDE          reduce using rule 24 (expr -> condition .)
    GT              reduce using rule 24 (expr -> condition .)
    LT              reduce using rule 24 (expr -> condition .)
    ET              reduce using rule 24 (expr -> condition .)
    GTE             reduce using rule 24 (expr -> condition .)
    LTE             reduce using rule 24 (expr -> condition .)
    NE              reduce using rule 24 (expr -> condition .)
    OUTPUT          reduce using rule 24 (expr -> condition .)
    IF              reduce using rule 24 (expr -> condition .)
    ASK             reduce using rule 24 (expr -> condition .)
    WHILE           reduce using rule 24 (expr -> condition .)
    PAUSE           reduce using rule 24 (expr -> condition .)
    FOREVER         reduce using rule 24 (expr -> condition .)
    EXIT            reduce using rule 24 (expr -> condition .)
    SET             reduce using rule 24 (expr -> condition .)
    REPEAT          reduce using rule 24 (expr -> condition .)
    $end            reduce using rule 24 (expr -> condition .)
    END             reduce using rule 24 (expr -> condition .)
    THEN            reduce using rule 24 (expr -> condition .)
    TIMES           reduce using rule 24 (expr -> condition .)
    RPAREN          reduce using rule 24 (expr -> condition .)
    TO              reduce using rule 24 (expr -> condition .)
    DO              reduce using rule 24 (expr -> condition .)


state 28

    (35) expr -> DIGIT .

    PLUS            reduce using rule 35 (expr -> DIGIT .)
    MINUS           reduce using rule 35 (expr -> DIGIT .)
    MULTIPLY        reduce using rule 35 (expr -> DIGIT .)
    DIVIDE          reduce using rule 35 (expr -> DIGIT .)
    GT              reduce using rule 35 (expr -> DIGIT .)
    LT              reduce using rule 35 (expr -> DIGIT .)
    ET              reduce using rule 35 (expr -> DIGIT .)
    GTE             reduce using rule 35 (expr -> DIGIT .)
    LTE             reduce using rule 35 (expr -> DIGIT .)
    NE              reduce using rule 35 (expr -> DIGIT .)
    OUTPUT          reduce using rule 35 (expr -> DIGIT .)
    IF              reduce using rule 35 (expr -> DIGIT .)
    ASK             reduce using rule 35 (expr -> DIGIT .)
    WHILE           reduce using rule 35 (expr -> DIGIT .)
    PAUSE           reduce using rule 35 (expr -> DIGIT .)
    FOREVER         reduce using rule 35 (expr -> DIGIT .)
    EXIT            reduce using rule 35 (expr -> DIGIT .)
    SET             reduce using rule 35 (expr -> DIGIT .)
    REPEAT          reduce using rule 35 (expr -> DIGIT .)
    $end            reduce using rule 35 (expr -> DIGIT .)
    END             reduce using rule 35 (expr -> DIGIT .)
    THEN            reduce using rule 35 (expr -> DIGIT .)
    TIMES           reduce using rule 35 (expr -> DIGIT .)
    RPAREN          reduce using rule 35 (expr -> DIGIT .)
    TO              reduce using rule 35 (expr -> DIGIT .)
    DO              reduce using rule 35 (expr -> DIGIT .)


state 29

    (36) expr -> ID .

    PLUS            reduce using rule 36 (expr -> ID .)
    MINUS           reduce using rule 36 (expr -> ID .)
    MULTIPLY        reduce using rule 36 (expr -> ID .)
    DIVIDE          reduce using rule 36 (expr -> ID .)
    GT              reduce using rule 36 (expr -> ID .)
    LT              reduce using rule 36 (expr -> ID .)
    ET              reduce using rule 36 (expr -> ID .)
    GTE             reduce using rule 36 (expr -> ID .)
    LTE             reduce using rule 36 (expr -> ID .)
    NE              reduce using rule 36 (expr -> ID .)
    OUTPUT          reduce using rule 36 (expr -> ID .)
    IF              reduce using rule 36 (expr -> ID .)
    ASK             reduce using rule 36 (expr -> ID .)
    WHILE           reduce using rule 36 (expr -> ID .)
    PAUSE           reduce using rule 36 (expr -> ID .)
    FOREVER         reduce using rule 36 (expr -> ID .)
    EXIT            reduce using rule 36 (expr -> ID .)
    SET             reduce using rule 36 (expr -> ID .)
    REPEAT          reduce using rule 36 (expr -> ID .)
    $end            reduce using rule 36 (expr -> ID .)
    END             reduce using rule 36 (expr -> ID .)
    THEN            reduce using rule 36 (expr -> ID .)
    TIMES           reduce using rule 36 (expr -> ID .)
    RPAREN          reduce using rule 36 (expr -> ID .)
    TO              reduce using rule 36 (expr -> ID .)
    DO              reduce using rule 36 (expr -> ID .)


state 30

    (37) expr -> LPAREN . expr RPAREN
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 55
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 31

    (38) expr -> RANDOM . NUMBER FROM expr TO expr

    NUMBER          shift and go to state 56


state 32

    (39) expr -> TEXT .

    PLUS            reduce using rule 39 (expr -> TEXT .)
    MINUS           reduce using rule 39 (expr -> TEXT .)
    MULTIPLY        reduce using rule 39 (expr -> TEXT .)
    DIVIDE          reduce using rule 39 (expr -> TEXT .)
    GT              reduce using rule 39 (expr -> TEXT .)
    LT              reduce using rule 39 (expr -> TEXT .)
    ET              reduce using rule 39 (expr -> TEXT .)
    GTE             reduce using rule 39 (expr -> TEXT .)
    LTE             reduce using rule 39 (expr -> TEXT .)
    NE              reduce using rule 39 (expr -> TEXT .)
    OUTPUT          reduce using rule 39 (expr -> TEXT .)
    IF              reduce using rule 39 (expr -> TEXT .)
    ASK             reduce using rule 39 (expr -> TEXT .)
    WHILE           reduce using rule 39 (expr -> TEXT .)
    PAUSE           reduce using rule 39 (expr -> TEXT .)
    FOREVER         reduce using rule 39 (expr -> TEXT .)
    EXIT            reduce using rule 39 (expr -> TEXT .)
    SET             reduce using rule 39 (expr -> TEXT .)
    REPEAT          reduce using rule 39 (expr -> TEXT .)
    $end            reduce using rule 39 (expr -> TEXT .)
    END             reduce using rule 39 (expr -> TEXT .)
    THEN            reduce using rule 39 (expr -> TEXT .)
    TIMES           reduce using rule 39 (expr -> TEXT .)
    RPAREN          reduce using rule 39 (expr -> TEXT .)
    TO              reduce using rule 39 (expr -> TEXT .)
    DO              reduce using rule 39 (expr -> TEXT .)


state 33

    (40) expr -> CONVERT . expr TO datatype
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 57
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 34

    (15) if_then_stmt -> IF expr . THEN body END
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

    THEN            shift and go to state 58
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54


state 35

    (16) input_stmt -> ASK expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

    OUTPUT          reduce using rule 16 (input_stmt -> ASK expr .)
    IF              reduce using rule 16 (input_stmt -> ASK expr .)
    ASK             reduce using rule 16 (input_stmt -> ASK expr .)
    WHILE           reduce using rule 16 (input_stmt -> ASK expr .)
    PAUSE           reduce using rule 16 (input_stmt -> ASK expr .)
    FOREVER         reduce using rule 16 (input_stmt -> ASK expr .)
    EXIT            reduce using rule 16 (input_stmt -> ASK expr .)
    SET             reduce using rule 16 (input_stmt -> ASK expr .)
    REPEAT          reduce using rule 16 (input_stmt -> ASK expr .)
    $end            reduce using rule 16 (input_stmt -> ASK expr .)
    END             reduce using rule 16 (input_stmt -> ASK expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54


state 36

    (17) while_stmt -> WHILE condition . DO body END
    (24) expr -> condition .

    DO              shift and go to state 59
    GT              reduce using rule 24 (expr -> condition .)
    LT              reduce using rule 24 (expr -> condition .)
    ET              reduce using rule 24 (expr -> condition .)
    GTE             reduce using rule 24 (expr -> condition .)
    LTE             reduce using rule 24 (expr -> condition .)
    NE              reduce using rule 24 (expr -> condition .)
    PLUS            reduce using rule 24 (expr -> condition .)
    MINUS           reduce using rule 24 (expr -> condition .)
    MULTIPLY        reduce using rule 24 (expr -> condition .)
    DIVIDE          reduce using rule 24 (expr -> condition .)


state 37

    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr

    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 38

    (19) repeat_stmt -> repeat body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (13) set_stmt -> . var_stmt TO expr
    (14) output_stmt -> . OUTPUT expr
    (15) if_then_stmt -> . IF expr THEN body END
    (16) input_stmt -> . ASK expr
    (17) while_stmt -> . WHILE condition DO body END
    (19) repeat_stmt -> . repeat body END
    (20) pause_stmt -> . PAUSE expr
    (21) forever_stmt -> . FOREVER DO body END
    (22) exit_stmt -> . EXIT LOOP
    (12) var_stmt -> . SET ID
    (18) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 60
    OUTPUT          shift and go to state 13
    IF              shift and go to state 14
    ASK             shift and go to state 15
    WHILE           shift and go to state 16
    PAUSE           shift and go to state 18
    FOREVER         shift and go to state 19
    EXIT            shift and go to state 20
    SET             shift and go to state 21
    REPEAT          shift and go to state 22

    repeat                         shift and go to state 17
    stmt                           shift and go to state 23
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    var_stmt                       shift and go to state 12

state 39

    (20) pause_stmt -> PAUSE expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

    OUTPUT          reduce using rule 20 (pause_stmt -> PAUSE expr .)
    IF              reduce using rule 20 (pause_stmt -> PAUSE expr .)
    ASK             reduce using rule 20 (pause_stmt -> PAUSE expr .)
    WHILE           reduce using rule 20 (pause_stmt -> PAUSE expr .)
    PAUSE           reduce using rule 20 (pause_stmt -> PAUSE expr .)
    FOREVER         reduce using rule 20 (pause_stmt -> PAUSE expr .)
    EXIT            reduce using rule 20 (pause_stmt -> PAUSE expr .)
    SET             reduce using rule 20 (pause_stmt -> PAUSE expr .)
    REPEAT          reduce using rule 20 (pause_stmt -> PAUSE expr .)
    $end            reduce using rule 20 (pause_stmt -> PAUSE expr .)
    END             reduce using rule 20 (pause_stmt -> PAUSE expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54


state 40

    (21) forever_stmt -> FOREVER DO . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (13) set_stmt -> . var_stmt TO expr
    (14) output_stmt -> . OUTPUT expr
    (15) if_then_stmt -> . IF expr THEN body END
    (16) input_stmt -> . ASK expr
    (17) while_stmt -> . WHILE condition DO body END
    (19) repeat_stmt -> . repeat body END
    (20) pause_stmt -> . PAUSE expr
    (21) forever_stmt -> . FOREVER DO body END
    (22) exit_stmt -> . EXIT LOOP
    (12) var_stmt -> . SET ID
    (18) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 13
    IF              shift and go to state 14
    ASK             shift and go to state 15
    WHILE           shift and go to state 16
    PAUSE           shift and go to state 18
    FOREVER         shift and go to state 19
    EXIT            shift and go to state 20
    SET             shift and go to state 21
    REPEAT          shift and go to state 22

    body                           shift and go to state 61
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    var_stmt                       shift and go to state 12
    repeat                         shift and go to state 17

state 41

    (22) exit_stmt -> EXIT LOOP .

    OUTPUT          reduce using rule 22 (exit_stmt -> EXIT LOOP .)
    IF              reduce using rule 22 (exit_stmt -> EXIT LOOP .)
    ASK             reduce using rule 22 (exit_stmt -> EXIT LOOP .)
    WHILE           reduce using rule 22 (exit_stmt -> EXIT LOOP .)
    PAUSE           reduce using rule 22 (exit_stmt -> EXIT LOOP .)
    FOREVER         reduce using rule 22 (exit_stmt -> EXIT LOOP .)
    EXIT            reduce using rule 22 (exit_stmt -> EXIT LOOP .)
    SET             reduce using rule 22 (exit_stmt -> EXIT LOOP .)
    REPEAT          reduce using rule 22 (exit_stmt -> EXIT LOOP .)
    $end            reduce using rule 22 (exit_stmt -> EXIT LOOP .)
    END             reduce using rule 22 (exit_stmt -> EXIT LOOP .)


state 42

    (12) var_stmt -> SET ID .

    TO              reduce using rule 12 (var_stmt -> SET ID .)


state 43

    (18) repeat -> REPEAT expr . TIMES USING expr
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

    TIMES           shift and go to state 62
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54


state 44

    (13) set_stmt -> var_stmt TO expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

    OUTPUT          reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    IF              reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    ASK             reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    WHILE           reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    PAUSE           reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    FOREVER         reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    EXIT            reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    SET             reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    REPEAT          reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    $end            reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    END             reduce using rule 13 (set_stmt -> var_stmt TO expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54


state 45

    (25) binop -> expr PLUS . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 63
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 46

    (26) binop -> expr MINUS . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 64
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 47

    (27) binop -> expr MULTIPLY . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 65
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 48

    (28) binop -> expr DIVIDE . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 66
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 49

    (29) condition -> expr GT . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 67
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 50

    (30) condition -> expr LT . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 68
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 51

    (31) condition -> expr ET . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 69
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 52

    (32) condition -> expr GTE . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 70
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 53

    (33) condition -> expr LTE . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 71
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 54

    (34) condition -> expr NE . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 72
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 55

    (37) expr -> LPAREN expr . RPAREN
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

    RPAREN          shift and go to state 73
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54


state 56

    (38) expr -> RANDOM NUMBER . FROM expr TO expr

    FROM            shift and go to state 74


state 57

    (40) expr -> CONVERT expr . TO datatype
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

    TO              shift and go to state 75
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54


state 58

    (15) if_then_stmt -> IF expr THEN . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (13) set_stmt -> . var_stmt TO expr
    (14) output_stmt -> . OUTPUT expr
    (15) if_then_stmt -> . IF expr THEN body END
    (16) input_stmt -> . ASK expr
    (17) while_stmt -> . WHILE condition DO body END
    (19) repeat_stmt -> . repeat body END
    (20) pause_stmt -> . PAUSE expr
    (21) forever_stmt -> . FOREVER DO body END
    (22) exit_stmt -> . EXIT LOOP
    (12) var_stmt -> . SET ID
    (18) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 13
    IF              shift and go to state 14
    ASK             shift and go to state 15
    WHILE           shift and go to state 16
    PAUSE           shift and go to state 18
    FOREVER         shift and go to state 19
    EXIT            shift and go to state 20
    SET             shift and go to state 21
    REPEAT          shift and go to state 22

    body                           shift and go to state 76
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    var_stmt                       shift and go to state 12
    repeat                         shift and go to state 17

state 59

    (17) while_stmt -> WHILE condition DO . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (13) set_stmt -> . var_stmt TO expr
    (14) output_stmt -> . OUTPUT expr
    (15) if_then_stmt -> . IF expr THEN body END
    (16) input_stmt -> . ASK expr
    (17) while_stmt -> . WHILE condition DO body END
    (19) repeat_stmt -> . repeat body END
    (20) pause_stmt -> . PAUSE expr
    (21) forever_stmt -> . FOREVER DO body END
    (22) exit_stmt -> . EXIT LOOP
    (12) var_stmt -> . SET ID
    (18) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 13
    IF              shift and go to state 14
    ASK             shift and go to state 15
    WHILE           shift and go to state 16
    PAUSE           shift and go to state 18
    FOREVER         shift and go to state 19
    EXIT            shift and go to state 20
    SET             shift and go to state 21
    REPEAT          shift and go to state 22

    body                           shift and go to state 77
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    var_stmt                       shift and go to state 12
    repeat                         shift and go to state 17

state 60

    (19) repeat_stmt -> repeat body END .

    OUTPUT          reduce using rule 19 (repeat_stmt -> repeat body END .)
    IF              reduce using rule 19 (repeat_stmt -> repeat body END .)
    ASK             reduce using rule 19 (repeat_stmt -> repeat body END .)
    WHILE           reduce using rule 19 (repeat_stmt -> repeat body END .)
    PAUSE           reduce using rule 19 (repeat_stmt -> repeat body END .)
    FOREVER         reduce using rule 19 (repeat_stmt -> repeat body END .)
    EXIT            reduce using rule 19 (repeat_stmt -> repeat body END .)
    SET             reduce using rule 19 (repeat_stmt -> repeat body END .)
    REPEAT          reduce using rule 19 (repeat_stmt -> repeat body END .)
    $end            reduce using rule 19 (repeat_stmt -> repeat body END .)
    END             reduce using rule 19 (repeat_stmt -> repeat body END .)


state 61

    (21) forever_stmt -> FOREVER DO body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (13) set_stmt -> . var_stmt TO expr
    (14) output_stmt -> . OUTPUT expr
    (15) if_then_stmt -> . IF expr THEN body END
    (16) input_stmt -> . ASK expr
    (17) while_stmt -> . WHILE condition DO body END
    (19) repeat_stmt -> . repeat body END
    (20) pause_stmt -> . PAUSE expr
    (21) forever_stmt -> . FOREVER DO body END
    (22) exit_stmt -> . EXIT LOOP
    (12) var_stmt -> . SET ID
    (18) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 78
    OUTPUT          shift and go to state 13
    IF              shift and go to state 14
    ASK             shift and go to state 15
    WHILE           shift and go to state 16
    PAUSE           shift and go to state 18
    FOREVER         shift and go to state 19
    EXIT            shift and go to state 20
    SET             shift and go to state 21
    REPEAT          shift and go to state 22

    stmt                           shift and go to state 23
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    var_stmt                       shift and go to state 12
    repeat                         shift and go to state 17

state 62

    (18) repeat -> REPEAT expr TIMES . USING expr

    USING           shift and go to state 79


state 63

    (25) binop -> expr PLUS expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 25 (binop -> expr PLUS expr .)
    IF              reduce using rule 25 (binop -> expr PLUS expr .)
    ASK             reduce using rule 25 (binop -> expr PLUS expr .)
    WHILE           reduce using rule 25 (binop -> expr PLUS expr .)
    PAUSE           reduce using rule 25 (binop -> expr PLUS expr .)
    FOREVER         reduce using rule 25 (binop -> expr PLUS expr .)
    EXIT            reduce using rule 25 (binop -> expr PLUS expr .)
    SET             reduce using rule 25 (binop -> expr PLUS expr .)
    REPEAT          reduce using rule 25 (binop -> expr PLUS expr .)
    $end            reduce using rule 25 (binop -> expr PLUS expr .)
    END             reduce using rule 25 (binop -> expr PLUS expr .)
    THEN            reduce using rule 25 (binop -> expr PLUS expr .)
    TIMES           reduce using rule 25 (binop -> expr PLUS expr .)
    RPAREN          reduce using rule 25 (binop -> expr PLUS expr .)
    TO              reduce using rule 25 (binop -> expr PLUS expr .)
    DO              reduce using rule 25 (binop -> expr PLUS expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 25 (binop -> expr PLUS expr .) ]
  ! MINUS           [ reduce using rule 25 (binop -> expr PLUS expr .) ]
  ! MULTIPLY        [ reduce using rule 25 (binop -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 25 (binop -> expr PLUS expr .) ]
  ! GT              [ reduce using rule 25 (binop -> expr PLUS expr .) ]
  ! LT              [ reduce using rule 25 (binop -> expr PLUS expr .) ]
  ! ET              [ reduce using rule 25 (binop -> expr PLUS expr .) ]
  ! GTE             [ reduce using rule 25 (binop -> expr PLUS expr .) ]
  ! LTE             [ reduce using rule 25 (binop -> expr PLUS expr .) ]
  ! NE              [ reduce using rule 25 (binop -> expr PLUS expr .) ]


state 64

    (26) binop -> expr MINUS expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 26 (binop -> expr MINUS expr .)
    IF              reduce using rule 26 (binop -> expr MINUS expr .)
    ASK             reduce using rule 26 (binop -> expr MINUS expr .)
    WHILE           reduce using rule 26 (binop -> expr MINUS expr .)
    PAUSE           reduce using rule 26 (binop -> expr MINUS expr .)
    FOREVER         reduce using rule 26 (binop -> expr MINUS expr .)
    EXIT            reduce using rule 26 (binop -> expr MINUS expr .)
    SET             reduce using rule 26 (binop -> expr MINUS expr .)
    REPEAT          reduce using rule 26 (binop -> expr MINUS expr .)
    $end            reduce using rule 26 (binop -> expr MINUS expr .)
    END             reduce using rule 26 (binop -> expr MINUS expr .)
    THEN            reduce using rule 26 (binop -> expr MINUS expr .)
    TIMES           reduce using rule 26 (binop -> expr MINUS expr .)
    RPAREN          reduce using rule 26 (binop -> expr MINUS expr .)
    TO              reduce using rule 26 (binop -> expr MINUS expr .)
    DO              reduce using rule 26 (binop -> expr MINUS expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 26 (binop -> expr MINUS expr .) ]
  ! MINUS           [ reduce using rule 26 (binop -> expr MINUS expr .) ]
  ! MULTIPLY        [ reduce using rule 26 (binop -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 26 (binop -> expr MINUS expr .) ]
  ! GT              [ reduce using rule 26 (binop -> expr MINUS expr .) ]
  ! LT              [ reduce using rule 26 (binop -> expr MINUS expr .) ]
  ! ET              [ reduce using rule 26 (binop -> expr MINUS expr .) ]
  ! GTE             [ reduce using rule 26 (binop -> expr MINUS expr .) ]
  ! LTE             [ reduce using rule 26 (binop -> expr MINUS expr .) ]
  ! NE              [ reduce using rule 26 (binop -> expr MINUS expr .) ]


state 65

    (27) binop -> expr MULTIPLY expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 27 (binop -> expr MULTIPLY expr .)
    IF              reduce using rule 27 (binop -> expr MULTIPLY expr .)
    ASK             reduce using rule 27 (binop -> expr MULTIPLY expr .)
    WHILE           reduce using rule 27 (binop -> expr MULTIPLY expr .)
    PAUSE           reduce using rule 27 (binop -> expr MULTIPLY expr .)
    FOREVER         reduce using rule 27 (binop -> expr MULTIPLY expr .)
    EXIT            reduce using rule 27 (binop -> expr MULTIPLY expr .)
    SET             reduce using rule 27 (binop -> expr MULTIPLY expr .)
    REPEAT          reduce using rule 27 (binop -> expr MULTIPLY expr .)
    $end            reduce using rule 27 (binop -> expr MULTIPLY expr .)
    END             reduce using rule 27 (binop -> expr MULTIPLY expr .)
    THEN            reduce using rule 27 (binop -> expr MULTIPLY expr .)
    TIMES           reduce using rule 27 (binop -> expr MULTIPLY expr .)
    RPAREN          reduce using rule 27 (binop -> expr MULTIPLY expr .)
    TO              reduce using rule 27 (binop -> expr MULTIPLY expr .)
    DO              reduce using rule 27 (binop -> expr MULTIPLY expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 27 (binop -> expr MULTIPLY expr .) ]
  ! MINUS           [ reduce using rule 27 (binop -> expr MULTIPLY expr .) ]
  ! MULTIPLY        [ reduce using rule 27 (binop -> expr MULTIPLY expr .) ]
  ! DIVIDE          [ reduce using rule 27 (binop -> expr MULTIPLY expr .) ]
  ! GT              [ reduce using rule 27 (binop -> expr MULTIPLY expr .) ]
  ! LT              [ reduce using rule 27 (binop -> expr MULTIPLY expr .) ]
  ! ET              [ reduce using rule 27 (binop -> expr MULTIPLY expr .) ]
  ! GTE             [ reduce using rule 27 (binop -> expr MULTIPLY expr .) ]
  ! LTE             [ reduce using rule 27 (binop -> expr MULTIPLY expr .) ]
  ! NE              [ reduce using rule 27 (binop -> expr MULTIPLY expr .) ]


state 66

    (28) binop -> expr DIVIDE expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 28 (binop -> expr DIVIDE expr .)
    IF              reduce using rule 28 (binop -> expr DIVIDE expr .)
    ASK             reduce using rule 28 (binop -> expr DIVIDE expr .)
    WHILE           reduce using rule 28 (binop -> expr DIVIDE expr .)
    PAUSE           reduce using rule 28 (binop -> expr DIVIDE expr .)
    FOREVER         reduce using rule 28 (binop -> expr DIVIDE expr .)
    EXIT            reduce using rule 28 (binop -> expr DIVIDE expr .)
    SET             reduce using rule 28 (binop -> expr DIVIDE expr .)
    REPEAT          reduce using rule 28 (binop -> expr DIVIDE expr .)
    $end            reduce using rule 28 (binop -> expr DIVIDE expr .)
    END             reduce using rule 28 (binop -> expr DIVIDE expr .)
    THEN            reduce using rule 28 (binop -> expr DIVIDE expr .)
    TIMES           reduce using rule 28 (binop -> expr DIVIDE expr .)
    RPAREN          reduce using rule 28 (binop -> expr DIVIDE expr .)
    TO              reduce using rule 28 (binop -> expr DIVIDE expr .)
    DO              reduce using rule 28 (binop -> expr DIVIDE expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 28 (binop -> expr DIVIDE expr .) ]
  ! MINUS           [ reduce using rule 28 (binop -> expr DIVIDE expr .) ]
  ! MULTIPLY        [ reduce using rule 28 (binop -> expr DIVIDE expr .) ]
  ! DIVIDE          [ reduce using rule 28 (binop -> expr DIVIDE expr .) ]
  ! GT              [ reduce using rule 28 (binop -> expr DIVIDE expr .) ]
  ! LT              [ reduce using rule 28 (binop -> expr DIVIDE expr .) ]
  ! ET              [ reduce using rule 28 (binop -> expr DIVIDE expr .) ]
  ! GTE             [ reduce using rule 28 (binop -> expr DIVIDE expr .) ]
  ! LTE             [ reduce using rule 28 (binop -> expr DIVIDE expr .) ]
  ! NE              [ reduce using rule 28 (binop -> expr DIVIDE expr .) ]


state 67

    (29) condition -> expr GT expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 29 (condition -> expr GT expr .)
    IF              reduce using rule 29 (condition -> expr GT expr .)
    ASK             reduce using rule 29 (condition -> expr GT expr .)
    WHILE           reduce using rule 29 (condition -> expr GT expr .)
    PAUSE           reduce using rule 29 (condition -> expr GT expr .)
    FOREVER         reduce using rule 29 (condition -> expr GT expr .)
    EXIT            reduce using rule 29 (condition -> expr GT expr .)
    SET             reduce using rule 29 (condition -> expr GT expr .)
    REPEAT          reduce using rule 29 (condition -> expr GT expr .)
    $end            reduce using rule 29 (condition -> expr GT expr .)
    END             reduce using rule 29 (condition -> expr GT expr .)
    THEN            reduce using rule 29 (condition -> expr GT expr .)
    DO              reduce using rule 29 (condition -> expr GT expr .)
    TIMES           reduce using rule 29 (condition -> expr GT expr .)
    RPAREN          reduce using rule 29 (condition -> expr GT expr .)
    TO              reduce using rule 29 (condition -> expr GT expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 29 (condition -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 29 (condition -> expr GT expr .) ]
  ! MULTIPLY        [ reduce using rule 29 (condition -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 29 (condition -> expr GT expr .) ]
  ! GT              [ reduce using rule 29 (condition -> expr GT expr .) ]
  ! LT              [ reduce using rule 29 (condition -> expr GT expr .) ]
  ! ET              [ reduce using rule 29 (condition -> expr GT expr .) ]
  ! GTE             [ reduce using rule 29 (condition -> expr GT expr .) ]
  ! LTE             [ reduce using rule 29 (condition -> expr GT expr .) ]
  ! NE              [ reduce using rule 29 (condition -> expr GT expr .) ]


state 68

    (30) condition -> expr LT expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 30 (condition -> expr LT expr .)
    IF              reduce using rule 30 (condition -> expr LT expr .)
    ASK             reduce using rule 30 (condition -> expr LT expr .)
    WHILE           reduce using rule 30 (condition -> expr LT expr .)
    PAUSE           reduce using rule 30 (condition -> expr LT expr .)
    FOREVER         reduce using rule 30 (condition -> expr LT expr .)
    EXIT            reduce using rule 30 (condition -> expr LT expr .)
    SET             reduce using rule 30 (condition -> expr LT expr .)
    REPEAT          reduce using rule 30 (condition -> expr LT expr .)
    $end            reduce using rule 30 (condition -> expr LT expr .)
    END             reduce using rule 30 (condition -> expr LT expr .)
    THEN            reduce using rule 30 (condition -> expr LT expr .)
    DO              reduce using rule 30 (condition -> expr LT expr .)
    TIMES           reduce using rule 30 (condition -> expr LT expr .)
    RPAREN          reduce using rule 30 (condition -> expr LT expr .)
    TO              reduce using rule 30 (condition -> expr LT expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 30 (condition -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 30 (condition -> expr LT expr .) ]
  ! MULTIPLY        [ reduce using rule 30 (condition -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 30 (condition -> expr LT expr .) ]
  ! GT              [ reduce using rule 30 (condition -> expr LT expr .) ]
  ! LT              [ reduce using rule 30 (condition -> expr LT expr .) ]
  ! ET              [ reduce using rule 30 (condition -> expr LT expr .) ]
  ! GTE             [ reduce using rule 30 (condition -> expr LT expr .) ]
  ! LTE             [ reduce using rule 30 (condition -> expr LT expr .) ]
  ! NE              [ reduce using rule 30 (condition -> expr LT expr .) ]


state 69

    (31) condition -> expr ET expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 31 (condition -> expr ET expr .)
    IF              reduce using rule 31 (condition -> expr ET expr .)
    ASK             reduce using rule 31 (condition -> expr ET expr .)
    WHILE           reduce using rule 31 (condition -> expr ET expr .)
    PAUSE           reduce using rule 31 (condition -> expr ET expr .)
    FOREVER         reduce using rule 31 (condition -> expr ET expr .)
    EXIT            reduce using rule 31 (condition -> expr ET expr .)
    SET             reduce using rule 31 (condition -> expr ET expr .)
    REPEAT          reduce using rule 31 (condition -> expr ET expr .)
    $end            reduce using rule 31 (condition -> expr ET expr .)
    END             reduce using rule 31 (condition -> expr ET expr .)
    THEN            reduce using rule 31 (condition -> expr ET expr .)
    DO              reduce using rule 31 (condition -> expr ET expr .)
    TIMES           reduce using rule 31 (condition -> expr ET expr .)
    RPAREN          reduce using rule 31 (condition -> expr ET expr .)
    TO              reduce using rule 31 (condition -> expr ET expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 31 (condition -> expr ET expr .) ]
  ! MINUS           [ reduce using rule 31 (condition -> expr ET expr .) ]
  ! MULTIPLY        [ reduce using rule 31 (condition -> expr ET expr .) ]
  ! DIVIDE          [ reduce using rule 31 (condition -> expr ET expr .) ]
  ! GT              [ reduce using rule 31 (condition -> expr ET expr .) ]
  ! LT              [ reduce using rule 31 (condition -> expr ET expr .) ]
  ! ET              [ reduce using rule 31 (condition -> expr ET expr .) ]
  ! GTE             [ reduce using rule 31 (condition -> expr ET expr .) ]
  ! LTE             [ reduce using rule 31 (condition -> expr ET expr .) ]
  ! NE              [ reduce using rule 31 (condition -> expr ET expr .) ]


state 70

    (32) condition -> expr GTE expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 32 (condition -> expr GTE expr .)
    IF              reduce using rule 32 (condition -> expr GTE expr .)
    ASK             reduce using rule 32 (condition -> expr GTE expr .)
    WHILE           reduce using rule 32 (condition -> expr GTE expr .)
    PAUSE           reduce using rule 32 (condition -> expr GTE expr .)
    FOREVER         reduce using rule 32 (condition -> expr GTE expr .)
    EXIT            reduce using rule 32 (condition -> expr GTE expr .)
    SET             reduce using rule 32 (condition -> expr GTE expr .)
    REPEAT          reduce using rule 32 (condition -> expr GTE expr .)
    $end            reduce using rule 32 (condition -> expr GTE expr .)
    END             reduce using rule 32 (condition -> expr GTE expr .)
    THEN            reduce using rule 32 (condition -> expr GTE expr .)
    DO              reduce using rule 32 (condition -> expr GTE expr .)
    TIMES           reduce using rule 32 (condition -> expr GTE expr .)
    RPAREN          reduce using rule 32 (condition -> expr GTE expr .)
    TO              reduce using rule 32 (condition -> expr GTE expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 32 (condition -> expr GTE expr .) ]
  ! MINUS           [ reduce using rule 32 (condition -> expr GTE expr .) ]
  ! MULTIPLY        [ reduce using rule 32 (condition -> expr GTE expr .) ]
  ! DIVIDE          [ reduce using rule 32 (condition -> expr GTE expr .) ]
  ! GT              [ reduce using rule 32 (condition -> expr GTE expr .) ]
  ! LT              [ reduce using rule 32 (condition -> expr GTE expr .) ]
  ! ET              [ reduce using rule 32 (condition -> expr GTE expr .) ]
  ! GTE             [ reduce using rule 32 (condition -> expr GTE expr .) ]
  ! LTE             [ reduce using rule 32 (condition -> expr GTE expr .) ]
  ! NE              [ reduce using rule 32 (condition -> expr GTE expr .) ]


state 71

    (33) condition -> expr LTE expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 33 (condition -> expr LTE expr .)
    IF              reduce using rule 33 (condition -> expr LTE expr .)
    ASK             reduce using rule 33 (condition -> expr LTE expr .)
    WHILE           reduce using rule 33 (condition -> expr LTE expr .)
    PAUSE           reduce using rule 33 (condition -> expr LTE expr .)
    FOREVER         reduce using rule 33 (condition -> expr LTE expr .)
    EXIT            reduce using rule 33 (condition -> expr LTE expr .)
    SET             reduce using rule 33 (condition -> expr LTE expr .)
    REPEAT          reduce using rule 33 (condition -> expr LTE expr .)
    $end            reduce using rule 33 (condition -> expr LTE expr .)
    END             reduce using rule 33 (condition -> expr LTE expr .)
    THEN            reduce using rule 33 (condition -> expr LTE expr .)
    DO              reduce using rule 33 (condition -> expr LTE expr .)
    TIMES           reduce using rule 33 (condition -> expr LTE expr .)
    RPAREN          reduce using rule 33 (condition -> expr LTE expr .)
    TO              reduce using rule 33 (condition -> expr LTE expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 33 (condition -> expr LTE expr .) ]
  ! MINUS           [ reduce using rule 33 (condition -> expr LTE expr .) ]
  ! MULTIPLY        [ reduce using rule 33 (condition -> expr LTE expr .) ]
  ! DIVIDE          [ reduce using rule 33 (condition -> expr LTE expr .) ]
  ! GT              [ reduce using rule 33 (condition -> expr LTE expr .) ]
  ! LT              [ reduce using rule 33 (condition -> expr LTE expr .) ]
  ! ET              [ reduce using rule 33 (condition -> expr LTE expr .) ]
  ! GTE             [ reduce using rule 33 (condition -> expr LTE expr .) ]
  ! LTE             [ reduce using rule 33 (condition -> expr LTE expr .) ]
  ! NE              [ reduce using rule 33 (condition -> expr LTE expr .) ]


state 72

    (34) condition -> expr NE expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 34 (condition -> expr NE expr .)
    IF              reduce using rule 34 (condition -> expr NE expr .)
    ASK             reduce using rule 34 (condition -> expr NE expr .)
    WHILE           reduce using rule 34 (condition -> expr NE expr .)
    PAUSE           reduce using rule 34 (condition -> expr NE expr .)
    FOREVER         reduce using rule 34 (condition -> expr NE expr .)
    EXIT            reduce using rule 34 (condition -> expr NE expr .)
    SET             reduce using rule 34 (condition -> expr NE expr .)
    REPEAT          reduce using rule 34 (condition -> expr NE expr .)
    $end            reduce using rule 34 (condition -> expr NE expr .)
    END             reduce using rule 34 (condition -> expr NE expr .)
    THEN            reduce using rule 34 (condition -> expr NE expr .)
    DO              reduce using rule 34 (condition -> expr NE expr .)
    TIMES           reduce using rule 34 (condition -> expr NE expr .)
    RPAREN          reduce using rule 34 (condition -> expr NE expr .)
    TO              reduce using rule 34 (condition -> expr NE expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 34 (condition -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 34 (condition -> expr NE expr .) ]
  ! MULTIPLY        [ reduce using rule 34 (condition -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 34 (condition -> expr NE expr .) ]
  ! GT              [ reduce using rule 34 (condition -> expr NE expr .) ]
  ! LT              [ reduce using rule 34 (condition -> expr NE expr .) ]
  ! ET              [ reduce using rule 34 (condition -> expr NE expr .) ]
  ! GTE             [ reduce using rule 34 (condition -> expr NE expr .) ]
  ! LTE             [ reduce using rule 34 (condition -> expr NE expr .) ]
  ! NE              [ reduce using rule 34 (condition -> expr NE expr .) ]


state 73

    (37) expr -> LPAREN expr RPAREN .

    PLUS            reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    MULTIPLY        reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    ET              reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    GTE             reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    LTE             reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    OUTPUT          reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    IF              reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    ASK             reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    WHILE           reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    PAUSE           reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    FOREVER         reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    EXIT            reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    SET             reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    REPEAT          reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    END             reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    THEN            reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    TO              reduce using rule 37 (expr -> LPAREN expr RPAREN .)
    DO              reduce using rule 37 (expr -> LPAREN expr RPAREN .)


state 74

    (38) expr -> RANDOM NUMBER FROM . expr TO expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 80
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 75

    (40) expr -> CONVERT expr TO . datatype
    (41) datatype -> . NUM
    (42) datatype -> . TXT

    NUM             shift and go to state 82
    TXT             shift and go to state 83

    datatype                       shift and go to state 81

state 76

    (15) if_then_stmt -> IF expr THEN body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (13) set_stmt -> . var_stmt TO expr
    (14) output_stmt -> . OUTPUT expr
    (15) if_then_stmt -> . IF expr THEN body END
    (16) input_stmt -> . ASK expr
    (17) while_stmt -> . WHILE condition DO body END
    (19) repeat_stmt -> . repeat body END
    (20) pause_stmt -> . PAUSE expr
    (21) forever_stmt -> . FOREVER DO body END
    (22) exit_stmt -> . EXIT LOOP
    (12) var_stmt -> . SET ID
    (18) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 84
    OUTPUT          shift and go to state 13
    IF              shift and go to state 14
    ASK             shift and go to state 15
    WHILE           shift and go to state 16
    PAUSE           shift and go to state 18
    FOREVER         shift and go to state 19
    EXIT            shift and go to state 20
    SET             shift and go to state 21
    REPEAT          shift and go to state 22

    stmt                           shift and go to state 23
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    var_stmt                       shift and go to state 12
    repeat                         shift and go to state 17

state 77

    (17) while_stmt -> WHILE condition DO body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (13) set_stmt -> . var_stmt TO expr
    (14) output_stmt -> . OUTPUT expr
    (15) if_then_stmt -> . IF expr THEN body END
    (16) input_stmt -> . ASK expr
    (17) while_stmt -> . WHILE condition DO body END
    (19) repeat_stmt -> . repeat body END
    (20) pause_stmt -> . PAUSE expr
    (21) forever_stmt -> . FOREVER DO body END
    (22) exit_stmt -> . EXIT LOOP
    (12) var_stmt -> . SET ID
    (18) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 85
    OUTPUT          shift and go to state 13
    IF              shift and go to state 14
    ASK             shift and go to state 15
    WHILE           shift and go to state 16
    PAUSE           shift and go to state 18
    FOREVER         shift and go to state 19
    EXIT            shift and go to state 20
    SET             shift and go to state 21
    REPEAT          shift and go to state 22

    stmt                           shift and go to state 23
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    var_stmt                       shift and go to state 12
    repeat                         shift and go to state 17

state 78

    (21) forever_stmt -> FOREVER DO body END .

    OUTPUT          reduce using rule 21 (forever_stmt -> FOREVER DO body END .)
    IF              reduce using rule 21 (forever_stmt -> FOREVER DO body END .)
    ASK             reduce using rule 21 (forever_stmt -> FOREVER DO body END .)
    WHILE           reduce using rule 21 (forever_stmt -> FOREVER DO body END .)
    PAUSE           reduce using rule 21 (forever_stmt -> FOREVER DO body END .)
    FOREVER         reduce using rule 21 (forever_stmt -> FOREVER DO body END .)
    EXIT            reduce using rule 21 (forever_stmt -> FOREVER DO body END .)
    SET             reduce using rule 21 (forever_stmt -> FOREVER DO body END .)
    REPEAT          reduce using rule 21 (forever_stmt -> FOREVER DO body END .)
    $end            reduce using rule 21 (forever_stmt -> FOREVER DO body END .)
    END             reduce using rule 21 (forever_stmt -> FOREVER DO body END .)


state 79

    (18) repeat -> REPEAT expr TIMES USING . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 86
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 80

    (38) expr -> RANDOM NUMBER FROM expr . TO expr
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

    TO              shift and go to state 87
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54


state 81

    (40) expr -> CONVERT expr TO datatype .

    PLUS            reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    MINUS           reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    MULTIPLY        reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    DIVIDE          reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    GT              reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    LT              reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    ET              reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    GTE             reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    LTE             reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    NE              reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    OUTPUT          reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    IF              reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    ASK             reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    WHILE           reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    PAUSE           reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    FOREVER         reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    EXIT            reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    SET             reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    REPEAT          reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    $end            reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    END             reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    THEN            reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    TIMES           reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    RPAREN          reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    TO              reduce using rule 40 (expr -> CONVERT expr TO datatype .)
    DO              reduce using rule 40 (expr -> CONVERT expr TO datatype .)


state 82

    (41) datatype -> NUM .

    PLUS            reduce using rule 41 (datatype -> NUM .)
    MINUS           reduce using rule 41 (datatype -> NUM .)
    MULTIPLY        reduce using rule 41 (datatype -> NUM .)
    DIVIDE          reduce using rule 41 (datatype -> NUM .)
    GT              reduce using rule 41 (datatype -> NUM .)
    LT              reduce using rule 41 (datatype -> NUM .)
    ET              reduce using rule 41 (datatype -> NUM .)
    GTE             reduce using rule 41 (datatype -> NUM .)
    LTE             reduce using rule 41 (datatype -> NUM .)
    NE              reduce using rule 41 (datatype -> NUM .)
    OUTPUT          reduce using rule 41 (datatype -> NUM .)
    IF              reduce using rule 41 (datatype -> NUM .)
    ASK             reduce using rule 41 (datatype -> NUM .)
    WHILE           reduce using rule 41 (datatype -> NUM .)
    PAUSE           reduce using rule 41 (datatype -> NUM .)
    FOREVER         reduce using rule 41 (datatype -> NUM .)
    EXIT            reduce using rule 41 (datatype -> NUM .)
    SET             reduce using rule 41 (datatype -> NUM .)
    REPEAT          reduce using rule 41 (datatype -> NUM .)
    $end            reduce using rule 41 (datatype -> NUM .)
    END             reduce using rule 41 (datatype -> NUM .)
    THEN            reduce using rule 41 (datatype -> NUM .)
    TIMES           reduce using rule 41 (datatype -> NUM .)
    RPAREN          reduce using rule 41 (datatype -> NUM .)
    TO              reduce using rule 41 (datatype -> NUM .)
    DO              reduce using rule 41 (datatype -> NUM .)


state 83

    (42) datatype -> TXT .

    PLUS            reduce using rule 42 (datatype -> TXT .)
    MINUS           reduce using rule 42 (datatype -> TXT .)
    MULTIPLY        reduce using rule 42 (datatype -> TXT .)
    DIVIDE          reduce using rule 42 (datatype -> TXT .)
    GT              reduce using rule 42 (datatype -> TXT .)
    LT              reduce using rule 42 (datatype -> TXT .)
    ET              reduce using rule 42 (datatype -> TXT .)
    GTE             reduce using rule 42 (datatype -> TXT .)
    LTE             reduce using rule 42 (datatype -> TXT .)
    NE              reduce using rule 42 (datatype -> TXT .)
    OUTPUT          reduce using rule 42 (datatype -> TXT .)
    IF              reduce using rule 42 (datatype -> TXT .)
    ASK             reduce using rule 42 (datatype -> TXT .)
    WHILE           reduce using rule 42 (datatype -> TXT .)
    PAUSE           reduce using rule 42 (datatype -> TXT .)
    FOREVER         reduce using rule 42 (datatype -> TXT .)
    EXIT            reduce using rule 42 (datatype -> TXT .)
    SET             reduce using rule 42 (datatype -> TXT .)
    REPEAT          reduce using rule 42 (datatype -> TXT .)
    $end            reduce using rule 42 (datatype -> TXT .)
    END             reduce using rule 42 (datatype -> TXT .)
    THEN            reduce using rule 42 (datatype -> TXT .)
    TIMES           reduce using rule 42 (datatype -> TXT .)
    RPAREN          reduce using rule 42 (datatype -> TXT .)
    TO              reduce using rule 42 (datatype -> TXT .)
    DO              reduce using rule 42 (datatype -> TXT .)


state 84

    (15) if_then_stmt -> IF expr THEN body END .

    OUTPUT          reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)
    IF              reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)
    ASK             reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)
    WHILE           reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)
    PAUSE           reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)
    FOREVER         reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)
    EXIT            reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)
    SET             reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)
    REPEAT          reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)
    $end            reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)
    END             reduce using rule 15 (if_then_stmt -> IF expr THEN body END .)


state 85

    (17) while_stmt -> WHILE condition DO body END .

    OUTPUT          reduce using rule 17 (while_stmt -> WHILE condition DO body END .)
    IF              reduce using rule 17 (while_stmt -> WHILE condition DO body END .)
    ASK             reduce using rule 17 (while_stmt -> WHILE condition DO body END .)
    WHILE           reduce using rule 17 (while_stmt -> WHILE condition DO body END .)
    PAUSE           reduce using rule 17 (while_stmt -> WHILE condition DO body END .)
    FOREVER         reduce using rule 17 (while_stmt -> WHILE condition DO body END .)
    EXIT            reduce using rule 17 (while_stmt -> WHILE condition DO body END .)
    SET             reduce using rule 17 (while_stmt -> WHILE condition DO body END .)
    REPEAT          reduce using rule 17 (while_stmt -> WHILE condition DO body END .)
    $end            reduce using rule 17 (while_stmt -> WHILE condition DO body END .)
    END             reduce using rule 17 (while_stmt -> WHILE condition DO body END .)


state 86

    (18) repeat -> REPEAT expr TIMES USING expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

    OUTPUT          reduce using rule 18 (repeat -> REPEAT expr TIMES USING expr .)
    IF              reduce using rule 18 (repeat -> REPEAT expr TIMES USING expr .)
    ASK             reduce using rule 18 (repeat -> REPEAT expr TIMES USING expr .)
    WHILE           reduce using rule 18 (repeat -> REPEAT expr TIMES USING expr .)
    PAUSE           reduce using rule 18 (repeat -> REPEAT expr TIMES USING expr .)
    FOREVER         reduce using rule 18 (repeat -> REPEAT expr TIMES USING expr .)
    EXIT            reduce using rule 18 (repeat -> REPEAT expr TIMES USING expr .)
    SET             reduce using rule 18 (repeat -> REPEAT expr TIMES USING expr .)
    REPEAT          reduce using rule 18 (repeat -> REPEAT expr TIMES USING expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54


state 87

    (38) expr -> RANDOM NUMBER FROM expr TO . expr
    (23) expr -> . binop
    (24) expr -> . condition
    (35) expr -> . DIGIT
    (36) expr -> . ID
    (37) expr -> . LPAREN expr RPAREN
    (38) expr -> . RANDOM NUMBER FROM expr TO expr
    (39) expr -> . TEXT
    (40) expr -> . CONVERT expr TO datatype
    (25) binop -> . expr PLUS expr
    (26) binop -> . expr MINUS expr
    (27) binop -> . expr MULTIPLY expr
    (28) binop -> . expr DIVIDE expr
    (29) condition -> . expr GT expr
    (30) condition -> . expr LT expr
    (31) condition -> . expr ET expr
    (32) condition -> . expr GTE expr
    (33) condition -> . expr LTE expr
    (34) condition -> . expr NE expr

    DIGIT           shift and go to state 28
    ID              shift and go to state 29
    LPAREN          shift and go to state 30
    RANDOM          shift and go to state 31
    TEXT            shift and go to state 32
    CONVERT         shift and go to state 33

    expr                           shift and go to state 88
    binop                          shift and go to state 26
    condition                      shift and go to state 27

state 88

    (38) expr -> RANDOM NUMBER FROM expr TO expr .
    (25) binop -> expr . PLUS expr
    (26) binop -> expr . MINUS expr
    (27) binop -> expr . MULTIPLY expr
    (28) binop -> expr . DIVIDE expr
    (29) condition -> expr . GT expr
    (30) condition -> expr . LT expr
    (31) condition -> expr . ET expr
    (32) condition -> expr . GTE expr
    (33) condition -> expr . LTE expr
    (34) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    IF              reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    ASK             reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    WHILE           reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    PAUSE           reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    FOREVER         reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    EXIT            reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    SET             reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    REPEAT          reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    $end            reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    END             reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    THEN            reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    TIMES           reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    RPAREN          reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    TO              reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    DO              reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    ET              shift and go to state 51
    GTE             shift and go to state 52
    LTE             shift and go to state 53
    NE              shift and go to state 54

  ! PLUS            [ reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! MINUS           [ reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! MULTIPLY        [ reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! DIVIDE          [ reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! GT              [ reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! LT              [ reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! ET              [ reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! GTE             [ reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! LTE             [ reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! NE              [ reduce using rule 38 (expr -> RANDOM NUMBER FROM expr TO expr .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 63 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 63 resolved as shift
WARNING: shift/reduce conflict for GT in state 63 resolved as shift
WARNING: shift/reduce conflict for LT in state 63 resolved as shift
WARNING: shift/reduce conflict for ET in state 63 resolved as shift
WARNING: shift/reduce conflict for GTE in state 63 resolved as shift
WARNING: shift/reduce conflict for LTE in state 63 resolved as shift
WARNING: shift/reduce conflict for NE in state 63 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 64 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 64 resolved as shift
WARNING: shift/reduce conflict for GT in state 64 resolved as shift
WARNING: shift/reduce conflict for LT in state 64 resolved as shift
WARNING: shift/reduce conflict for ET in state 64 resolved as shift
WARNING: shift/reduce conflict for GTE in state 64 resolved as shift
WARNING: shift/reduce conflict for LTE in state 64 resolved as shift
WARNING: shift/reduce conflict for NE in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 65 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 65 resolved as shift
WARNING: shift/reduce conflict for GT in state 65 resolved as shift
WARNING: shift/reduce conflict for LT in state 65 resolved as shift
WARNING: shift/reduce conflict for ET in state 65 resolved as shift
WARNING: shift/reduce conflict for GTE in state 65 resolved as shift
WARNING: shift/reduce conflict for LTE in state 65 resolved as shift
WARNING: shift/reduce conflict for NE in state 65 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 66 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 66 resolved as shift
WARNING: shift/reduce conflict for GT in state 66 resolved as shift
WARNING: shift/reduce conflict for LT in state 66 resolved as shift
WARNING: shift/reduce conflict for ET in state 66 resolved as shift
WARNING: shift/reduce conflict for GTE in state 66 resolved as shift
WARNING: shift/reduce conflict for LTE in state 66 resolved as shift
WARNING: shift/reduce conflict for NE in state 66 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 67 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 67 resolved as shift
WARNING: shift/reduce conflict for GT in state 67 resolved as shift
WARNING: shift/reduce conflict for LT in state 67 resolved as shift
WARNING: shift/reduce conflict for ET in state 67 resolved as shift
WARNING: shift/reduce conflict for GTE in state 67 resolved as shift
WARNING: shift/reduce conflict for LTE in state 67 resolved as shift
WARNING: shift/reduce conflict for NE in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 68 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 68 resolved as shift
WARNING: shift/reduce conflict for GT in state 68 resolved as shift
WARNING: shift/reduce conflict for LT in state 68 resolved as shift
WARNING: shift/reduce conflict for ET in state 68 resolved as shift
WARNING: shift/reduce conflict for GTE in state 68 resolved as shift
WARNING: shift/reduce conflict for LTE in state 68 resolved as shift
WARNING: shift/reduce conflict for NE in state 68 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 69 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 69 resolved as shift
WARNING: shift/reduce conflict for GT in state 69 resolved as shift
WARNING: shift/reduce conflict for LT in state 69 resolved as shift
WARNING: shift/reduce conflict for ET in state 69 resolved as shift
WARNING: shift/reduce conflict for GTE in state 69 resolved as shift
WARNING: shift/reduce conflict for LTE in state 69 resolved as shift
WARNING: shift/reduce conflict for NE in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 70 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 70 resolved as shift
WARNING: shift/reduce conflict for GT in state 70 resolved as shift
WARNING: shift/reduce conflict for LT in state 70 resolved as shift
WARNING: shift/reduce conflict for ET in state 70 resolved as shift
WARNING: shift/reduce conflict for GTE in state 70 resolved as shift
WARNING: shift/reduce conflict for LTE in state 70 resolved as shift
WARNING: shift/reduce conflict for NE in state 70 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 71 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 71 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 71 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 71 resolved as shift
WARNING: shift/reduce conflict for GT in state 71 resolved as shift
WARNING: shift/reduce conflict for LT in state 71 resolved as shift
WARNING: shift/reduce conflict for ET in state 71 resolved as shift
WARNING: shift/reduce conflict for GTE in state 71 resolved as shift
WARNING: shift/reduce conflict for LTE in state 71 resolved as shift
WARNING: shift/reduce conflict for NE in state 71 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 72 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 72 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 72 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 72 resolved as shift
WARNING: shift/reduce conflict for GT in state 72 resolved as shift
WARNING: shift/reduce conflict for LT in state 72 resolved as shift
WARNING: shift/reduce conflict for ET in state 72 resolved as shift
WARNING: shift/reduce conflict for GTE in state 72 resolved as shift
WARNING: shift/reduce conflict for LTE in state 72 resolved as shift
WARNING: shift/reduce conflict for NE in state 72 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 88 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 88 resolved as shift
WARNING: shift/reduce conflict for GT in state 88 resolved as shift
WARNING: shift/reduce conflict for LT in state 88 resolved as shift
WARNING: shift/reduce conflict for ET in state 88 resolved as shift
WARNING: shift/reduce conflict for GTE in state 88 resolved as shift
WARNING: shift/reduce conflict for LTE in state 88 resolved as shift
WARNING: shift/reduce conflict for NE in state 88 resolved as shift
