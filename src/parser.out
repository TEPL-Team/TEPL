Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> body
Rule 1     body -> stmt
Rule 2     body -> body stmt
Rule 3     stmt -> set_stmt
Rule 4     stmt -> output_stmt
Rule 5     stmt -> if_then_stmt
Rule 6     stmt -> input_stmt
Rule 7     stmt -> while_stmt
Rule 8     stmt -> repeat_stmt
Rule 9     stmt -> pause_stmt
Rule 10    stmt -> forever_stmt
Rule 11    stmt -> exit_stmt
Rule 12    stmt -> function_stmt
Rule 13    stmt -> return_stmt
Rule 14    stmt -> call_stmt
Rule 15    var_stmt -> SET ID
Rule 16    set_stmt -> var_stmt TO expr
Rule 17    output_stmt -> OUTPUT expr
Rule 18    if_then_stmt -> IF expr THEN body END
Rule 19    input_stmt -> ASK expr
Rule 20    while_stmt -> WHILE condition DO body END
Rule 21    repeat -> REPEAT expr TIMES USING expr
Rule 22    repeat_stmt -> repeat body END
Rule 23    pause_stmt -> PAUSE expr
Rule 24    forever_stmt -> FOREVER DO body END
Rule 25    exit_stmt -> EXIT LOOP
Rule 26    function_stmt -> FUNCTION expr WITH params MEANS body END
Rule 27    return_stmt -> RETURN expr
Rule 28    call_stmt -> ID params
Rule 29    expr -> binop
Rule 30    expr -> condition
Rule 31    expr -> CALL expr params
Rule 32    binop -> expr PLUS expr
Rule 33    binop -> expr MINUS expr
Rule 34    binop -> expr MULTIPLY expr
Rule 35    binop -> expr DIVIDE expr
Rule 36    condition -> expr GT expr
Rule 37    condition -> expr LT expr
Rule 38    condition -> expr ET expr
Rule 39    condition -> expr GTE expr
Rule 40    condition -> expr LTE expr
Rule 41    condition -> expr NE expr
Rule 42    expr -> DIGIT
Rule 43    expr -> ID
Rule 44    expr -> LPAREN expr RPAREN
Rule 45    expr -> RANDOM NUMBER FROM expr TO expr
Rule 46    expr -> TEXT
Rule 47    expr -> CONVERT expr TO datatype
Rule 48    datatype -> NUM
Rule 49    datatype -> TXT
Rule 50    params -> expr
Rule 51    params -> params expr

Terminals, with rules where they appear

ASK                  : 19
CALL                 : 31
COMMENT              : 
CONVERT              : 47
DIGIT                : 42
DIVIDE               : 35
DO                   : 20 24
END                  : 18 20 22 24 26
ET                   : 38
EXIT                 : 25
FOREVER              : 24
FROM                 : 45
FUNCTION             : 26
GT                   : 36
GTE                  : 39
ID                   : 15 28 43
IF                   : 18
LOOP                 : 25
LPAREN               : 44
LT                   : 37
LTE                  : 40
MEANS                : 26
MINUS                : 33
MULTIPLY             : 34
NE                   : 41
NUM                  : 48
NUMBER               : 45
OUTPUT               : 17
PAUSE                : 23
PLUS                 : 32
RANDOM               : 45
REPEAT               : 21
RETURN               : 27
RPAREN               : 44
SET                  : 15
TEXT                 : 46
THEN                 : 18
TIMES                : 21
TO                   : 16 45 47
TXT                  : 49
USING                : 21
WHILE                : 20
WITH                 : 26
error                : 

Nonterminals, with rules where they appear

binop                : 29
body                 : 2 18 20 22 24 26 0
call_stmt            : 14
condition            : 20 30
datatype             : 47
exit_stmt            : 11
expr                 : 16 17 18 19 21 21 23 26 27 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 44 45 45 47 50 51
forever_stmt         : 10
function_stmt        : 12
if_then_stmt         : 5
input_stmt           : 6
output_stmt          : 4
params               : 26 28 31 51
pause_stmt           : 9
repeat               : 22
repeat_stmt          : 8
return_stmt          : 13
set_stmt             : 3
stmt                 : 1 2
var_stmt             : 16
while_stmt           : 7

Parsing method: LALR

state 0

    (0) S' -> . body
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    body                           shift and go to state 1
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15
    repeat                         shift and go to state 20

state 1

    (0) S' -> body .
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    stmt                           shift and go to state 29
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15
    repeat                         shift and go to state 20

state 2

    (1) body -> stmt .

    OUTPUT          reduce using rule 1 (body -> stmt .)
    IF              reduce using rule 1 (body -> stmt .)
    ASK             reduce using rule 1 (body -> stmt .)
    WHILE           reduce using rule 1 (body -> stmt .)
    PAUSE           reduce using rule 1 (body -> stmt .)
    FOREVER         reduce using rule 1 (body -> stmt .)
    EXIT            reduce using rule 1 (body -> stmt .)
    FUNCTION        reduce using rule 1 (body -> stmt .)
    RETURN          reduce using rule 1 (body -> stmt .)
    ID              reduce using rule 1 (body -> stmt .)
    SET             reduce using rule 1 (body -> stmt .)
    REPEAT          reduce using rule 1 (body -> stmt .)
    $end            reduce using rule 1 (body -> stmt .)
    END             reduce using rule 1 (body -> stmt .)


state 3

    (3) stmt -> set_stmt .

    OUTPUT          reduce using rule 3 (stmt -> set_stmt .)
    IF              reduce using rule 3 (stmt -> set_stmt .)
    ASK             reduce using rule 3 (stmt -> set_stmt .)
    WHILE           reduce using rule 3 (stmt -> set_stmt .)
    PAUSE           reduce using rule 3 (stmt -> set_stmt .)
    FOREVER         reduce using rule 3 (stmt -> set_stmt .)
    EXIT            reduce using rule 3 (stmt -> set_stmt .)
    FUNCTION        reduce using rule 3 (stmt -> set_stmt .)
    RETURN          reduce using rule 3 (stmt -> set_stmt .)
    ID              reduce using rule 3 (stmt -> set_stmt .)
    SET             reduce using rule 3 (stmt -> set_stmt .)
    REPEAT          reduce using rule 3 (stmt -> set_stmt .)
    $end            reduce using rule 3 (stmt -> set_stmt .)
    END             reduce using rule 3 (stmt -> set_stmt .)


state 4

    (4) stmt -> output_stmt .

    OUTPUT          reduce using rule 4 (stmt -> output_stmt .)
    IF              reduce using rule 4 (stmt -> output_stmt .)
    ASK             reduce using rule 4 (stmt -> output_stmt .)
    WHILE           reduce using rule 4 (stmt -> output_stmt .)
    PAUSE           reduce using rule 4 (stmt -> output_stmt .)
    FOREVER         reduce using rule 4 (stmt -> output_stmt .)
    EXIT            reduce using rule 4 (stmt -> output_stmt .)
    FUNCTION        reduce using rule 4 (stmt -> output_stmt .)
    RETURN          reduce using rule 4 (stmt -> output_stmt .)
    ID              reduce using rule 4 (stmt -> output_stmt .)
    SET             reduce using rule 4 (stmt -> output_stmt .)
    REPEAT          reduce using rule 4 (stmt -> output_stmt .)
    $end            reduce using rule 4 (stmt -> output_stmt .)
    END             reduce using rule 4 (stmt -> output_stmt .)


state 5

    (5) stmt -> if_then_stmt .

    OUTPUT          reduce using rule 5 (stmt -> if_then_stmt .)
    IF              reduce using rule 5 (stmt -> if_then_stmt .)
    ASK             reduce using rule 5 (stmt -> if_then_stmt .)
    WHILE           reduce using rule 5 (stmt -> if_then_stmt .)
    PAUSE           reduce using rule 5 (stmt -> if_then_stmt .)
    FOREVER         reduce using rule 5 (stmt -> if_then_stmt .)
    EXIT            reduce using rule 5 (stmt -> if_then_stmt .)
    FUNCTION        reduce using rule 5 (stmt -> if_then_stmt .)
    RETURN          reduce using rule 5 (stmt -> if_then_stmt .)
    ID              reduce using rule 5 (stmt -> if_then_stmt .)
    SET             reduce using rule 5 (stmt -> if_then_stmt .)
    REPEAT          reduce using rule 5 (stmt -> if_then_stmt .)
    $end            reduce using rule 5 (stmt -> if_then_stmt .)
    END             reduce using rule 5 (stmt -> if_then_stmt .)


state 6

    (6) stmt -> input_stmt .

    OUTPUT          reduce using rule 6 (stmt -> input_stmt .)
    IF              reduce using rule 6 (stmt -> input_stmt .)
    ASK             reduce using rule 6 (stmt -> input_stmt .)
    WHILE           reduce using rule 6 (stmt -> input_stmt .)
    PAUSE           reduce using rule 6 (stmt -> input_stmt .)
    FOREVER         reduce using rule 6 (stmt -> input_stmt .)
    EXIT            reduce using rule 6 (stmt -> input_stmt .)
    FUNCTION        reduce using rule 6 (stmt -> input_stmt .)
    RETURN          reduce using rule 6 (stmt -> input_stmt .)
    ID              reduce using rule 6 (stmt -> input_stmt .)
    SET             reduce using rule 6 (stmt -> input_stmt .)
    REPEAT          reduce using rule 6 (stmt -> input_stmt .)
    $end            reduce using rule 6 (stmt -> input_stmt .)
    END             reduce using rule 6 (stmt -> input_stmt .)


state 7

    (7) stmt -> while_stmt .

    OUTPUT          reduce using rule 7 (stmt -> while_stmt .)
    IF              reduce using rule 7 (stmt -> while_stmt .)
    ASK             reduce using rule 7 (stmt -> while_stmt .)
    WHILE           reduce using rule 7 (stmt -> while_stmt .)
    PAUSE           reduce using rule 7 (stmt -> while_stmt .)
    FOREVER         reduce using rule 7 (stmt -> while_stmt .)
    EXIT            reduce using rule 7 (stmt -> while_stmt .)
    FUNCTION        reduce using rule 7 (stmt -> while_stmt .)
    RETURN          reduce using rule 7 (stmt -> while_stmt .)
    ID              reduce using rule 7 (stmt -> while_stmt .)
    SET             reduce using rule 7 (stmt -> while_stmt .)
    REPEAT          reduce using rule 7 (stmt -> while_stmt .)
    $end            reduce using rule 7 (stmt -> while_stmt .)
    END             reduce using rule 7 (stmt -> while_stmt .)


state 8

    (8) stmt -> repeat_stmt .

    OUTPUT          reduce using rule 8 (stmt -> repeat_stmt .)
    IF              reduce using rule 8 (stmt -> repeat_stmt .)
    ASK             reduce using rule 8 (stmt -> repeat_stmt .)
    WHILE           reduce using rule 8 (stmt -> repeat_stmt .)
    PAUSE           reduce using rule 8 (stmt -> repeat_stmt .)
    FOREVER         reduce using rule 8 (stmt -> repeat_stmt .)
    EXIT            reduce using rule 8 (stmt -> repeat_stmt .)
    FUNCTION        reduce using rule 8 (stmt -> repeat_stmt .)
    RETURN          reduce using rule 8 (stmt -> repeat_stmt .)
    ID              reduce using rule 8 (stmt -> repeat_stmt .)
    SET             reduce using rule 8 (stmt -> repeat_stmt .)
    REPEAT          reduce using rule 8 (stmt -> repeat_stmt .)
    $end            reduce using rule 8 (stmt -> repeat_stmt .)
    END             reduce using rule 8 (stmt -> repeat_stmt .)


state 9

    (9) stmt -> pause_stmt .

    OUTPUT          reduce using rule 9 (stmt -> pause_stmt .)
    IF              reduce using rule 9 (stmt -> pause_stmt .)
    ASK             reduce using rule 9 (stmt -> pause_stmt .)
    WHILE           reduce using rule 9 (stmt -> pause_stmt .)
    PAUSE           reduce using rule 9 (stmt -> pause_stmt .)
    FOREVER         reduce using rule 9 (stmt -> pause_stmt .)
    EXIT            reduce using rule 9 (stmt -> pause_stmt .)
    FUNCTION        reduce using rule 9 (stmt -> pause_stmt .)
    RETURN          reduce using rule 9 (stmt -> pause_stmt .)
    ID              reduce using rule 9 (stmt -> pause_stmt .)
    SET             reduce using rule 9 (stmt -> pause_stmt .)
    REPEAT          reduce using rule 9 (stmt -> pause_stmt .)
    $end            reduce using rule 9 (stmt -> pause_stmt .)
    END             reduce using rule 9 (stmt -> pause_stmt .)


state 10

    (10) stmt -> forever_stmt .

    OUTPUT          reduce using rule 10 (stmt -> forever_stmt .)
    IF              reduce using rule 10 (stmt -> forever_stmt .)
    ASK             reduce using rule 10 (stmt -> forever_stmt .)
    WHILE           reduce using rule 10 (stmt -> forever_stmt .)
    PAUSE           reduce using rule 10 (stmt -> forever_stmt .)
    FOREVER         reduce using rule 10 (stmt -> forever_stmt .)
    EXIT            reduce using rule 10 (stmt -> forever_stmt .)
    FUNCTION        reduce using rule 10 (stmt -> forever_stmt .)
    RETURN          reduce using rule 10 (stmt -> forever_stmt .)
    ID              reduce using rule 10 (stmt -> forever_stmt .)
    SET             reduce using rule 10 (stmt -> forever_stmt .)
    REPEAT          reduce using rule 10 (stmt -> forever_stmt .)
    $end            reduce using rule 10 (stmt -> forever_stmt .)
    END             reduce using rule 10 (stmt -> forever_stmt .)


state 11

    (11) stmt -> exit_stmt .

    OUTPUT          reduce using rule 11 (stmt -> exit_stmt .)
    IF              reduce using rule 11 (stmt -> exit_stmt .)
    ASK             reduce using rule 11 (stmt -> exit_stmt .)
    WHILE           reduce using rule 11 (stmt -> exit_stmt .)
    PAUSE           reduce using rule 11 (stmt -> exit_stmt .)
    FOREVER         reduce using rule 11 (stmt -> exit_stmt .)
    EXIT            reduce using rule 11 (stmt -> exit_stmt .)
    FUNCTION        reduce using rule 11 (stmt -> exit_stmt .)
    RETURN          reduce using rule 11 (stmt -> exit_stmt .)
    ID              reduce using rule 11 (stmt -> exit_stmt .)
    SET             reduce using rule 11 (stmt -> exit_stmt .)
    REPEAT          reduce using rule 11 (stmt -> exit_stmt .)
    $end            reduce using rule 11 (stmt -> exit_stmt .)
    END             reduce using rule 11 (stmt -> exit_stmt .)


state 12

    (12) stmt -> function_stmt .

    OUTPUT          reduce using rule 12 (stmt -> function_stmt .)
    IF              reduce using rule 12 (stmt -> function_stmt .)
    ASK             reduce using rule 12 (stmt -> function_stmt .)
    WHILE           reduce using rule 12 (stmt -> function_stmt .)
    PAUSE           reduce using rule 12 (stmt -> function_stmt .)
    FOREVER         reduce using rule 12 (stmt -> function_stmt .)
    EXIT            reduce using rule 12 (stmt -> function_stmt .)
    FUNCTION        reduce using rule 12 (stmt -> function_stmt .)
    RETURN          reduce using rule 12 (stmt -> function_stmt .)
    ID              reduce using rule 12 (stmt -> function_stmt .)
    SET             reduce using rule 12 (stmt -> function_stmt .)
    REPEAT          reduce using rule 12 (stmt -> function_stmt .)
    $end            reduce using rule 12 (stmt -> function_stmt .)
    END             reduce using rule 12 (stmt -> function_stmt .)


state 13

    (13) stmt -> return_stmt .

    OUTPUT          reduce using rule 13 (stmt -> return_stmt .)
    IF              reduce using rule 13 (stmt -> return_stmt .)
    ASK             reduce using rule 13 (stmt -> return_stmt .)
    WHILE           reduce using rule 13 (stmt -> return_stmt .)
    PAUSE           reduce using rule 13 (stmt -> return_stmt .)
    FOREVER         reduce using rule 13 (stmt -> return_stmt .)
    EXIT            reduce using rule 13 (stmt -> return_stmt .)
    FUNCTION        reduce using rule 13 (stmt -> return_stmt .)
    RETURN          reduce using rule 13 (stmt -> return_stmt .)
    ID              reduce using rule 13 (stmt -> return_stmt .)
    SET             reduce using rule 13 (stmt -> return_stmt .)
    REPEAT          reduce using rule 13 (stmt -> return_stmt .)
    $end            reduce using rule 13 (stmt -> return_stmt .)
    END             reduce using rule 13 (stmt -> return_stmt .)


state 14

    (14) stmt -> call_stmt .

    OUTPUT          reduce using rule 14 (stmt -> call_stmt .)
    IF              reduce using rule 14 (stmt -> call_stmt .)
    ASK             reduce using rule 14 (stmt -> call_stmt .)
    WHILE           reduce using rule 14 (stmt -> call_stmt .)
    PAUSE           reduce using rule 14 (stmt -> call_stmt .)
    FOREVER         reduce using rule 14 (stmt -> call_stmt .)
    EXIT            reduce using rule 14 (stmt -> call_stmt .)
    FUNCTION        reduce using rule 14 (stmt -> call_stmt .)
    RETURN          reduce using rule 14 (stmt -> call_stmt .)
    ID              reduce using rule 14 (stmt -> call_stmt .)
    SET             reduce using rule 14 (stmt -> call_stmt .)
    REPEAT          reduce using rule 14 (stmt -> call_stmt .)
    $end            reduce using rule 14 (stmt -> call_stmt .)
    END             reduce using rule 14 (stmt -> call_stmt .)


state 15

    (16) set_stmt -> var_stmt . TO expr

    TO              shift and go to state 30


state 16

    (17) output_stmt -> OUTPUT . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 31
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 17

    (18) if_then_stmt -> IF . expr THEN body END
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 41
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 18

    (19) input_stmt -> ASK . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 42
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 19

    (20) while_stmt -> WHILE . condition DO body END
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    condition                      shift and go to state 43
    expr                           shift and go to state 44
    binop                          shift and go to state 32

state 20

    (22) repeat_stmt -> repeat . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    repeat                         shift and go to state 20
    body                           shift and go to state 45
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15

state 21

    (23) pause_stmt -> PAUSE . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 46
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 22

    (24) forever_stmt -> FOREVER . DO body END

    DO              shift and go to state 47


state 23

    (25) exit_stmt -> EXIT . LOOP

    LOOP            shift and go to state 48


state 24

    (26) function_stmt -> FUNCTION . expr WITH params MEANS body END
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 49
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 25

    (27) return_stmt -> RETURN . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 50
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 26

    (28) call_stmt -> ID . params
    (50) params -> . expr
    (51) params -> . params expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    params                         shift and go to state 51
    expr                           shift and go to state 52
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 27

    (15) var_stmt -> SET . ID

    ID              shift and go to state 53


state 28

    (21) repeat -> REPEAT . expr TIMES USING expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 54
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 29

    (2) body -> body stmt .

    OUTPUT          reduce using rule 2 (body -> body stmt .)
    IF              reduce using rule 2 (body -> body stmt .)
    ASK             reduce using rule 2 (body -> body stmt .)
    WHILE           reduce using rule 2 (body -> body stmt .)
    PAUSE           reduce using rule 2 (body -> body stmt .)
    FOREVER         reduce using rule 2 (body -> body stmt .)
    EXIT            reduce using rule 2 (body -> body stmt .)
    FUNCTION        reduce using rule 2 (body -> body stmt .)
    RETURN          reduce using rule 2 (body -> body stmt .)
    ID              reduce using rule 2 (body -> body stmt .)
    SET             reduce using rule 2 (body -> body stmt .)
    REPEAT          reduce using rule 2 (body -> body stmt .)
    $end            reduce using rule 2 (body -> body stmt .)
    END             reduce using rule 2 (body -> body stmt .)


state 30

    (16) set_stmt -> var_stmt TO . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 55
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 31

    (17) output_stmt -> OUTPUT expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    OUTPUT          reduce using rule 17 (output_stmt -> OUTPUT expr .)
    IF              reduce using rule 17 (output_stmt -> OUTPUT expr .)
    ASK             reduce using rule 17 (output_stmt -> OUTPUT expr .)
    WHILE           reduce using rule 17 (output_stmt -> OUTPUT expr .)
    PAUSE           reduce using rule 17 (output_stmt -> OUTPUT expr .)
    FOREVER         reduce using rule 17 (output_stmt -> OUTPUT expr .)
    EXIT            reduce using rule 17 (output_stmt -> OUTPUT expr .)
    FUNCTION        reduce using rule 17 (output_stmt -> OUTPUT expr .)
    RETURN          reduce using rule 17 (output_stmt -> OUTPUT expr .)
    ID              reduce using rule 17 (output_stmt -> OUTPUT expr .)
    SET             reduce using rule 17 (output_stmt -> OUTPUT expr .)
    REPEAT          reduce using rule 17 (output_stmt -> OUTPUT expr .)
    $end            reduce using rule 17 (output_stmt -> OUTPUT expr .)
    END             reduce using rule 17 (output_stmt -> OUTPUT expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 32

    (29) expr -> binop .

    PLUS            reduce using rule 29 (expr -> binop .)
    MINUS           reduce using rule 29 (expr -> binop .)
    MULTIPLY        reduce using rule 29 (expr -> binop .)
    DIVIDE          reduce using rule 29 (expr -> binop .)
    GT              reduce using rule 29 (expr -> binop .)
    LT              reduce using rule 29 (expr -> binop .)
    ET              reduce using rule 29 (expr -> binop .)
    GTE             reduce using rule 29 (expr -> binop .)
    LTE             reduce using rule 29 (expr -> binop .)
    NE              reduce using rule 29 (expr -> binop .)
    OUTPUT          reduce using rule 29 (expr -> binop .)
    IF              reduce using rule 29 (expr -> binop .)
    ASK             reduce using rule 29 (expr -> binop .)
    WHILE           reduce using rule 29 (expr -> binop .)
    PAUSE           reduce using rule 29 (expr -> binop .)
    FOREVER         reduce using rule 29 (expr -> binop .)
    EXIT            reduce using rule 29 (expr -> binop .)
    FUNCTION        reduce using rule 29 (expr -> binop .)
    RETURN          reduce using rule 29 (expr -> binop .)
    ID              reduce using rule 29 (expr -> binop .)
    SET             reduce using rule 29 (expr -> binop .)
    REPEAT          reduce using rule 29 (expr -> binop .)
    $end            reduce using rule 29 (expr -> binop .)
    END             reduce using rule 29 (expr -> binop .)
    THEN            reduce using rule 29 (expr -> binop .)
    WITH            reduce using rule 29 (expr -> binop .)
    CALL            reduce using rule 29 (expr -> binop .)
    DIGIT           reduce using rule 29 (expr -> binop .)
    LPAREN          reduce using rule 29 (expr -> binop .)
    RANDOM          reduce using rule 29 (expr -> binop .)
    TEXT            reduce using rule 29 (expr -> binop .)
    CONVERT         reduce using rule 29 (expr -> binop .)
    TIMES           reduce using rule 29 (expr -> binop .)
    RPAREN          reduce using rule 29 (expr -> binop .)
    TO              reduce using rule 29 (expr -> binop .)
    DO              reduce using rule 29 (expr -> binop .)
    MEANS           reduce using rule 29 (expr -> binop .)


state 33

    (30) expr -> condition .

    PLUS            reduce using rule 30 (expr -> condition .)
    MINUS           reduce using rule 30 (expr -> condition .)
    MULTIPLY        reduce using rule 30 (expr -> condition .)
    DIVIDE          reduce using rule 30 (expr -> condition .)
    GT              reduce using rule 30 (expr -> condition .)
    LT              reduce using rule 30 (expr -> condition .)
    ET              reduce using rule 30 (expr -> condition .)
    GTE             reduce using rule 30 (expr -> condition .)
    LTE             reduce using rule 30 (expr -> condition .)
    NE              reduce using rule 30 (expr -> condition .)
    OUTPUT          reduce using rule 30 (expr -> condition .)
    IF              reduce using rule 30 (expr -> condition .)
    ASK             reduce using rule 30 (expr -> condition .)
    WHILE           reduce using rule 30 (expr -> condition .)
    PAUSE           reduce using rule 30 (expr -> condition .)
    FOREVER         reduce using rule 30 (expr -> condition .)
    EXIT            reduce using rule 30 (expr -> condition .)
    FUNCTION        reduce using rule 30 (expr -> condition .)
    RETURN          reduce using rule 30 (expr -> condition .)
    ID              reduce using rule 30 (expr -> condition .)
    SET             reduce using rule 30 (expr -> condition .)
    REPEAT          reduce using rule 30 (expr -> condition .)
    $end            reduce using rule 30 (expr -> condition .)
    END             reduce using rule 30 (expr -> condition .)
    THEN            reduce using rule 30 (expr -> condition .)
    WITH            reduce using rule 30 (expr -> condition .)
    CALL            reduce using rule 30 (expr -> condition .)
    DIGIT           reduce using rule 30 (expr -> condition .)
    LPAREN          reduce using rule 30 (expr -> condition .)
    RANDOM          reduce using rule 30 (expr -> condition .)
    TEXT            reduce using rule 30 (expr -> condition .)
    CONVERT         reduce using rule 30 (expr -> condition .)
    TIMES           reduce using rule 30 (expr -> condition .)
    RPAREN          reduce using rule 30 (expr -> condition .)
    TO              reduce using rule 30 (expr -> condition .)
    DO              reduce using rule 30 (expr -> condition .)
    MEANS           reduce using rule 30 (expr -> condition .)


state 34

    (31) expr -> CALL . expr params
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 66
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 35

    (42) expr -> DIGIT .

    PLUS            reduce using rule 42 (expr -> DIGIT .)
    MINUS           reduce using rule 42 (expr -> DIGIT .)
    MULTIPLY        reduce using rule 42 (expr -> DIGIT .)
    DIVIDE          reduce using rule 42 (expr -> DIGIT .)
    GT              reduce using rule 42 (expr -> DIGIT .)
    LT              reduce using rule 42 (expr -> DIGIT .)
    ET              reduce using rule 42 (expr -> DIGIT .)
    GTE             reduce using rule 42 (expr -> DIGIT .)
    LTE             reduce using rule 42 (expr -> DIGIT .)
    NE              reduce using rule 42 (expr -> DIGIT .)
    OUTPUT          reduce using rule 42 (expr -> DIGIT .)
    IF              reduce using rule 42 (expr -> DIGIT .)
    ASK             reduce using rule 42 (expr -> DIGIT .)
    WHILE           reduce using rule 42 (expr -> DIGIT .)
    PAUSE           reduce using rule 42 (expr -> DIGIT .)
    FOREVER         reduce using rule 42 (expr -> DIGIT .)
    EXIT            reduce using rule 42 (expr -> DIGIT .)
    FUNCTION        reduce using rule 42 (expr -> DIGIT .)
    RETURN          reduce using rule 42 (expr -> DIGIT .)
    ID              reduce using rule 42 (expr -> DIGIT .)
    SET             reduce using rule 42 (expr -> DIGIT .)
    REPEAT          reduce using rule 42 (expr -> DIGIT .)
    $end            reduce using rule 42 (expr -> DIGIT .)
    END             reduce using rule 42 (expr -> DIGIT .)
    THEN            reduce using rule 42 (expr -> DIGIT .)
    WITH            reduce using rule 42 (expr -> DIGIT .)
    CALL            reduce using rule 42 (expr -> DIGIT .)
    DIGIT           reduce using rule 42 (expr -> DIGIT .)
    LPAREN          reduce using rule 42 (expr -> DIGIT .)
    RANDOM          reduce using rule 42 (expr -> DIGIT .)
    TEXT            reduce using rule 42 (expr -> DIGIT .)
    CONVERT         reduce using rule 42 (expr -> DIGIT .)
    TIMES           reduce using rule 42 (expr -> DIGIT .)
    RPAREN          reduce using rule 42 (expr -> DIGIT .)
    TO              reduce using rule 42 (expr -> DIGIT .)
    DO              reduce using rule 42 (expr -> DIGIT .)
    MEANS           reduce using rule 42 (expr -> DIGIT .)


state 36

    (43) expr -> ID .

    PLUS            reduce using rule 43 (expr -> ID .)
    MINUS           reduce using rule 43 (expr -> ID .)
    MULTIPLY        reduce using rule 43 (expr -> ID .)
    DIVIDE          reduce using rule 43 (expr -> ID .)
    GT              reduce using rule 43 (expr -> ID .)
    LT              reduce using rule 43 (expr -> ID .)
    ET              reduce using rule 43 (expr -> ID .)
    GTE             reduce using rule 43 (expr -> ID .)
    LTE             reduce using rule 43 (expr -> ID .)
    NE              reduce using rule 43 (expr -> ID .)
    OUTPUT          reduce using rule 43 (expr -> ID .)
    IF              reduce using rule 43 (expr -> ID .)
    ASK             reduce using rule 43 (expr -> ID .)
    WHILE           reduce using rule 43 (expr -> ID .)
    PAUSE           reduce using rule 43 (expr -> ID .)
    FOREVER         reduce using rule 43 (expr -> ID .)
    EXIT            reduce using rule 43 (expr -> ID .)
    FUNCTION        reduce using rule 43 (expr -> ID .)
    RETURN          reduce using rule 43 (expr -> ID .)
    ID              reduce using rule 43 (expr -> ID .)
    SET             reduce using rule 43 (expr -> ID .)
    REPEAT          reduce using rule 43 (expr -> ID .)
    $end            reduce using rule 43 (expr -> ID .)
    END             reduce using rule 43 (expr -> ID .)
    THEN            reduce using rule 43 (expr -> ID .)
    WITH            reduce using rule 43 (expr -> ID .)
    CALL            reduce using rule 43 (expr -> ID .)
    DIGIT           reduce using rule 43 (expr -> ID .)
    LPAREN          reduce using rule 43 (expr -> ID .)
    RANDOM          reduce using rule 43 (expr -> ID .)
    TEXT            reduce using rule 43 (expr -> ID .)
    CONVERT         reduce using rule 43 (expr -> ID .)
    TIMES           reduce using rule 43 (expr -> ID .)
    RPAREN          reduce using rule 43 (expr -> ID .)
    TO              reduce using rule 43 (expr -> ID .)
    DO              reduce using rule 43 (expr -> ID .)
    MEANS           reduce using rule 43 (expr -> ID .)


state 37

    (44) expr -> LPAREN . expr RPAREN
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 67
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 38

    (45) expr -> RANDOM . NUMBER FROM expr TO expr

    NUMBER          shift and go to state 68


state 39

    (46) expr -> TEXT .

    PLUS            reduce using rule 46 (expr -> TEXT .)
    MINUS           reduce using rule 46 (expr -> TEXT .)
    MULTIPLY        reduce using rule 46 (expr -> TEXT .)
    DIVIDE          reduce using rule 46 (expr -> TEXT .)
    GT              reduce using rule 46 (expr -> TEXT .)
    LT              reduce using rule 46 (expr -> TEXT .)
    ET              reduce using rule 46 (expr -> TEXT .)
    GTE             reduce using rule 46 (expr -> TEXT .)
    LTE             reduce using rule 46 (expr -> TEXT .)
    NE              reduce using rule 46 (expr -> TEXT .)
    OUTPUT          reduce using rule 46 (expr -> TEXT .)
    IF              reduce using rule 46 (expr -> TEXT .)
    ASK             reduce using rule 46 (expr -> TEXT .)
    WHILE           reduce using rule 46 (expr -> TEXT .)
    PAUSE           reduce using rule 46 (expr -> TEXT .)
    FOREVER         reduce using rule 46 (expr -> TEXT .)
    EXIT            reduce using rule 46 (expr -> TEXT .)
    FUNCTION        reduce using rule 46 (expr -> TEXT .)
    RETURN          reduce using rule 46 (expr -> TEXT .)
    ID              reduce using rule 46 (expr -> TEXT .)
    SET             reduce using rule 46 (expr -> TEXT .)
    REPEAT          reduce using rule 46 (expr -> TEXT .)
    $end            reduce using rule 46 (expr -> TEXT .)
    END             reduce using rule 46 (expr -> TEXT .)
    THEN            reduce using rule 46 (expr -> TEXT .)
    WITH            reduce using rule 46 (expr -> TEXT .)
    CALL            reduce using rule 46 (expr -> TEXT .)
    DIGIT           reduce using rule 46 (expr -> TEXT .)
    LPAREN          reduce using rule 46 (expr -> TEXT .)
    RANDOM          reduce using rule 46 (expr -> TEXT .)
    TEXT            reduce using rule 46 (expr -> TEXT .)
    CONVERT         reduce using rule 46 (expr -> TEXT .)
    TIMES           reduce using rule 46 (expr -> TEXT .)
    RPAREN          reduce using rule 46 (expr -> TEXT .)
    TO              reduce using rule 46 (expr -> TEXT .)
    DO              reduce using rule 46 (expr -> TEXT .)
    MEANS           reduce using rule 46 (expr -> TEXT .)


state 40

    (47) expr -> CONVERT . expr TO datatype
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 69
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 41

    (18) if_then_stmt -> IF expr . THEN body END
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    THEN            shift and go to state 70
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 42

    (19) input_stmt -> ASK expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    OUTPUT          reduce using rule 19 (input_stmt -> ASK expr .)
    IF              reduce using rule 19 (input_stmt -> ASK expr .)
    ASK             reduce using rule 19 (input_stmt -> ASK expr .)
    WHILE           reduce using rule 19 (input_stmt -> ASK expr .)
    PAUSE           reduce using rule 19 (input_stmt -> ASK expr .)
    FOREVER         reduce using rule 19 (input_stmt -> ASK expr .)
    EXIT            reduce using rule 19 (input_stmt -> ASK expr .)
    FUNCTION        reduce using rule 19 (input_stmt -> ASK expr .)
    RETURN          reduce using rule 19 (input_stmt -> ASK expr .)
    ID              reduce using rule 19 (input_stmt -> ASK expr .)
    SET             reduce using rule 19 (input_stmt -> ASK expr .)
    REPEAT          reduce using rule 19 (input_stmt -> ASK expr .)
    $end            reduce using rule 19 (input_stmt -> ASK expr .)
    END             reduce using rule 19 (input_stmt -> ASK expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 43

    (20) while_stmt -> WHILE condition . DO body END
    (30) expr -> condition .

    DO              shift and go to state 71
    GT              reduce using rule 30 (expr -> condition .)
    LT              reduce using rule 30 (expr -> condition .)
    ET              reduce using rule 30 (expr -> condition .)
    GTE             reduce using rule 30 (expr -> condition .)
    LTE             reduce using rule 30 (expr -> condition .)
    NE              reduce using rule 30 (expr -> condition .)
    PLUS            reduce using rule 30 (expr -> condition .)
    MINUS           reduce using rule 30 (expr -> condition .)
    MULTIPLY        reduce using rule 30 (expr -> condition .)
    DIVIDE          reduce using rule 30 (expr -> condition .)


state 44

    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr

    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59


state 45

    (22) repeat_stmt -> repeat body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 72
    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    repeat                         shift and go to state 20
    stmt                           shift and go to state 29
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15

state 46

    (23) pause_stmt -> PAUSE expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    OUTPUT          reduce using rule 23 (pause_stmt -> PAUSE expr .)
    IF              reduce using rule 23 (pause_stmt -> PAUSE expr .)
    ASK             reduce using rule 23 (pause_stmt -> PAUSE expr .)
    WHILE           reduce using rule 23 (pause_stmt -> PAUSE expr .)
    PAUSE           reduce using rule 23 (pause_stmt -> PAUSE expr .)
    FOREVER         reduce using rule 23 (pause_stmt -> PAUSE expr .)
    EXIT            reduce using rule 23 (pause_stmt -> PAUSE expr .)
    FUNCTION        reduce using rule 23 (pause_stmt -> PAUSE expr .)
    RETURN          reduce using rule 23 (pause_stmt -> PAUSE expr .)
    ID              reduce using rule 23 (pause_stmt -> PAUSE expr .)
    SET             reduce using rule 23 (pause_stmt -> PAUSE expr .)
    REPEAT          reduce using rule 23 (pause_stmt -> PAUSE expr .)
    $end            reduce using rule 23 (pause_stmt -> PAUSE expr .)
    END             reduce using rule 23 (pause_stmt -> PAUSE expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 47

    (24) forever_stmt -> FOREVER DO . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    body                           shift and go to state 73
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15
    repeat                         shift and go to state 20

state 48

    (25) exit_stmt -> EXIT LOOP .

    OUTPUT          reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    IF              reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    ASK             reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    WHILE           reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    PAUSE           reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    FOREVER         reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    EXIT            reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    FUNCTION        reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    RETURN          reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    ID              reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    SET             reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    REPEAT          reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    $end            reduce using rule 25 (exit_stmt -> EXIT LOOP .)
    END             reduce using rule 25 (exit_stmt -> EXIT LOOP .)


state 49

    (26) function_stmt -> FUNCTION expr . WITH params MEANS body END
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    WITH            shift and go to state 74
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 50

    (27) return_stmt -> RETURN expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    OUTPUT          reduce using rule 27 (return_stmt -> RETURN expr .)
    IF              reduce using rule 27 (return_stmt -> RETURN expr .)
    ASK             reduce using rule 27 (return_stmt -> RETURN expr .)
    WHILE           reduce using rule 27 (return_stmt -> RETURN expr .)
    PAUSE           reduce using rule 27 (return_stmt -> RETURN expr .)
    FOREVER         reduce using rule 27 (return_stmt -> RETURN expr .)
    EXIT            reduce using rule 27 (return_stmt -> RETURN expr .)
    FUNCTION        reduce using rule 27 (return_stmt -> RETURN expr .)
    RETURN          reduce using rule 27 (return_stmt -> RETURN expr .)
    ID              reduce using rule 27 (return_stmt -> RETURN expr .)
    SET             reduce using rule 27 (return_stmt -> RETURN expr .)
    REPEAT          reduce using rule 27 (return_stmt -> RETURN expr .)
    $end            reduce using rule 27 (return_stmt -> RETURN expr .)
    END             reduce using rule 27 (return_stmt -> RETURN expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 51

    (28) call_stmt -> ID params .
    (51) params -> params . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

  ! shift/reduce conflict for ID resolved as shift
    OUTPUT          reduce using rule 28 (call_stmt -> ID params .)
    IF              reduce using rule 28 (call_stmt -> ID params .)
    ASK             reduce using rule 28 (call_stmt -> ID params .)
    WHILE           reduce using rule 28 (call_stmt -> ID params .)
    PAUSE           reduce using rule 28 (call_stmt -> ID params .)
    FOREVER         reduce using rule 28 (call_stmt -> ID params .)
    EXIT            reduce using rule 28 (call_stmt -> ID params .)
    FUNCTION        reduce using rule 28 (call_stmt -> ID params .)
    RETURN          reduce using rule 28 (call_stmt -> ID params .)
    SET             reduce using rule 28 (call_stmt -> ID params .)
    REPEAT          reduce using rule 28 (call_stmt -> ID params .)
    $end            reduce using rule 28 (call_stmt -> ID params .)
    END             reduce using rule 28 (call_stmt -> ID params .)
    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

  ! ID              [ reduce using rule 28 (call_stmt -> ID params .) ]

    expr                           shift and go to state 75
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 52

    (50) params -> expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    CALL            reduce using rule 50 (params -> expr .)
    DIGIT           reduce using rule 50 (params -> expr .)
    ID              reduce using rule 50 (params -> expr .)
    LPAREN          reduce using rule 50 (params -> expr .)
    RANDOM          reduce using rule 50 (params -> expr .)
    TEXT            reduce using rule 50 (params -> expr .)
    CONVERT         reduce using rule 50 (params -> expr .)
    OUTPUT          reduce using rule 50 (params -> expr .)
    IF              reduce using rule 50 (params -> expr .)
    ASK             reduce using rule 50 (params -> expr .)
    WHILE           reduce using rule 50 (params -> expr .)
    PAUSE           reduce using rule 50 (params -> expr .)
    FOREVER         reduce using rule 50 (params -> expr .)
    EXIT            reduce using rule 50 (params -> expr .)
    FUNCTION        reduce using rule 50 (params -> expr .)
    RETURN          reduce using rule 50 (params -> expr .)
    SET             reduce using rule 50 (params -> expr .)
    REPEAT          reduce using rule 50 (params -> expr .)
    $end            reduce using rule 50 (params -> expr .)
    END             reduce using rule 50 (params -> expr .)
    THEN            reduce using rule 50 (params -> expr .)
    WITH            reduce using rule 50 (params -> expr .)
    TIMES           reduce using rule 50 (params -> expr .)
    RPAREN          reduce using rule 50 (params -> expr .)
    TO              reduce using rule 50 (params -> expr .)
    DO              reduce using rule 50 (params -> expr .)
    MEANS           reduce using rule 50 (params -> expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 50 (params -> expr .) ]
  ! MINUS           [ reduce using rule 50 (params -> expr .) ]
  ! MULTIPLY        [ reduce using rule 50 (params -> expr .) ]
  ! DIVIDE          [ reduce using rule 50 (params -> expr .) ]
  ! GT              [ reduce using rule 50 (params -> expr .) ]
  ! LT              [ reduce using rule 50 (params -> expr .) ]
  ! ET              [ reduce using rule 50 (params -> expr .) ]
  ! GTE             [ reduce using rule 50 (params -> expr .) ]
  ! LTE             [ reduce using rule 50 (params -> expr .) ]
  ! NE              [ reduce using rule 50 (params -> expr .) ]


state 53

    (15) var_stmt -> SET ID .

    TO              reduce using rule 15 (var_stmt -> SET ID .)


state 54

    (21) repeat -> REPEAT expr . TIMES USING expr
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    TIMES           shift and go to state 76
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 55

    (16) set_stmt -> var_stmt TO expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    OUTPUT          reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    IF              reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    ASK             reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    WHILE           reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    PAUSE           reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    FOREVER         reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    EXIT            reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    FUNCTION        reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    RETURN          reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    ID              reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    SET             reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    REPEAT          reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    $end            reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    END             reduce using rule 16 (set_stmt -> var_stmt TO expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 56

    (32) binop -> expr PLUS . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 77
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 57

    (33) binop -> expr MINUS . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 78
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 58

    (34) binop -> expr MULTIPLY . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 79
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 59

    (35) binop -> expr DIVIDE . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 80
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 60

    (36) condition -> expr GT . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 81
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 61

    (37) condition -> expr LT . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 82
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 62

    (38) condition -> expr ET . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 83
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 63

    (39) condition -> expr GTE . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 84
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 64

    (40) condition -> expr LTE . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 85
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 65

    (41) condition -> expr NE . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 86
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 66

    (31) expr -> CALL expr . params
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr
    (50) params -> . expr
    (51) params -> . params expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65
    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 52
    params                         shift and go to state 87
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 67

    (44) expr -> LPAREN expr . RPAREN
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    RPAREN          shift and go to state 88
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 68

    (45) expr -> RANDOM NUMBER . FROM expr TO expr

    FROM            shift and go to state 89


state 69

    (47) expr -> CONVERT expr . TO datatype
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    TO              shift and go to state 90
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 70

    (18) if_then_stmt -> IF expr THEN . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    body                           shift and go to state 91
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15
    repeat                         shift and go to state 20

state 71

    (20) while_stmt -> WHILE condition DO . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    body                           shift and go to state 92
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15
    repeat                         shift and go to state 20

state 72

    (22) repeat_stmt -> repeat body END .

    OUTPUT          reduce using rule 22 (repeat_stmt -> repeat body END .)
    IF              reduce using rule 22 (repeat_stmt -> repeat body END .)
    ASK             reduce using rule 22 (repeat_stmt -> repeat body END .)
    WHILE           reduce using rule 22 (repeat_stmt -> repeat body END .)
    PAUSE           reduce using rule 22 (repeat_stmt -> repeat body END .)
    FOREVER         reduce using rule 22 (repeat_stmt -> repeat body END .)
    EXIT            reduce using rule 22 (repeat_stmt -> repeat body END .)
    FUNCTION        reduce using rule 22 (repeat_stmt -> repeat body END .)
    RETURN          reduce using rule 22 (repeat_stmt -> repeat body END .)
    ID              reduce using rule 22 (repeat_stmt -> repeat body END .)
    SET             reduce using rule 22 (repeat_stmt -> repeat body END .)
    REPEAT          reduce using rule 22 (repeat_stmt -> repeat body END .)
    $end            reduce using rule 22 (repeat_stmt -> repeat body END .)
    END             reduce using rule 22 (repeat_stmt -> repeat body END .)


state 73

    (24) forever_stmt -> FOREVER DO body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 93
    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    stmt                           shift and go to state 29
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15
    repeat                         shift and go to state 20

state 74

    (26) function_stmt -> FUNCTION expr WITH . params MEANS body END
    (50) params -> . expr
    (51) params -> . params expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 52
    params                         shift and go to state 94
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 75

    (51) params -> params expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    CALL            reduce using rule 51 (params -> params expr .)
    DIGIT           reduce using rule 51 (params -> params expr .)
    ID              reduce using rule 51 (params -> params expr .)
    LPAREN          reduce using rule 51 (params -> params expr .)
    RANDOM          reduce using rule 51 (params -> params expr .)
    TEXT            reduce using rule 51 (params -> params expr .)
    CONVERT         reduce using rule 51 (params -> params expr .)
    OUTPUT          reduce using rule 51 (params -> params expr .)
    IF              reduce using rule 51 (params -> params expr .)
    ASK             reduce using rule 51 (params -> params expr .)
    WHILE           reduce using rule 51 (params -> params expr .)
    PAUSE           reduce using rule 51 (params -> params expr .)
    FOREVER         reduce using rule 51 (params -> params expr .)
    EXIT            reduce using rule 51 (params -> params expr .)
    FUNCTION        reduce using rule 51 (params -> params expr .)
    RETURN          reduce using rule 51 (params -> params expr .)
    SET             reduce using rule 51 (params -> params expr .)
    REPEAT          reduce using rule 51 (params -> params expr .)
    $end            reduce using rule 51 (params -> params expr .)
    END             reduce using rule 51 (params -> params expr .)
    THEN            reduce using rule 51 (params -> params expr .)
    WITH            reduce using rule 51 (params -> params expr .)
    TIMES           reduce using rule 51 (params -> params expr .)
    RPAREN          reduce using rule 51 (params -> params expr .)
    TO              reduce using rule 51 (params -> params expr .)
    DO              reduce using rule 51 (params -> params expr .)
    MEANS           reduce using rule 51 (params -> params expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 51 (params -> params expr .) ]
  ! MINUS           [ reduce using rule 51 (params -> params expr .) ]
  ! MULTIPLY        [ reduce using rule 51 (params -> params expr .) ]
  ! DIVIDE          [ reduce using rule 51 (params -> params expr .) ]
  ! GT              [ reduce using rule 51 (params -> params expr .) ]
  ! LT              [ reduce using rule 51 (params -> params expr .) ]
  ! ET              [ reduce using rule 51 (params -> params expr .) ]
  ! GTE             [ reduce using rule 51 (params -> params expr .) ]
  ! LTE             [ reduce using rule 51 (params -> params expr .) ]
  ! NE              [ reduce using rule 51 (params -> params expr .) ]


state 76

    (21) repeat -> REPEAT expr TIMES . USING expr

    USING           shift and go to state 95


state 77

    (32) binop -> expr PLUS expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 32 (binop -> expr PLUS expr .)
    IF              reduce using rule 32 (binop -> expr PLUS expr .)
    ASK             reduce using rule 32 (binop -> expr PLUS expr .)
    WHILE           reduce using rule 32 (binop -> expr PLUS expr .)
    PAUSE           reduce using rule 32 (binop -> expr PLUS expr .)
    FOREVER         reduce using rule 32 (binop -> expr PLUS expr .)
    EXIT            reduce using rule 32 (binop -> expr PLUS expr .)
    FUNCTION        reduce using rule 32 (binop -> expr PLUS expr .)
    RETURN          reduce using rule 32 (binop -> expr PLUS expr .)
    ID              reduce using rule 32 (binop -> expr PLUS expr .)
    SET             reduce using rule 32 (binop -> expr PLUS expr .)
    REPEAT          reduce using rule 32 (binop -> expr PLUS expr .)
    $end            reduce using rule 32 (binop -> expr PLUS expr .)
    END             reduce using rule 32 (binop -> expr PLUS expr .)
    THEN            reduce using rule 32 (binop -> expr PLUS expr .)
    WITH            reduce using rule 32 (binop -> expr PLUS expr .)
    CALL            reduce using rule 32 (binop -> expr PLUS expr .)
    DIGIT           reduce using rule 32 (binop -> expr PLUS expr .)
    LPAREN          reduce using rule 32 (binop -> expr PLUS expr .)
    RANDOM          reduce using rule 32 (binop -> expr PLUS expr .)
    TEXT            reduce using rule 32 (binop -> expr PLUS expr .)
    CONVERT         reduce using rule 32 (binop -> expr PLUS expr .)
    TIMES           reduce using rule 32 (binop -> expr PLUS expr .)
    RPAREN          reduce using rule 32 (binop -> expr PLUS expr .)
    TO              reduce using rule 32 (binop -> expr PLUS expr .)
    DO              reduce using rule 32 (binop -> expr PLUS expr .)
    MEANS           reduce using rule 32 (binop -> expr PLUS expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 32 (binop -> expr PLUS expr .) ]
  ! MINUS           [ reduce using rule 32 (binop -> expr PLUS expr .) ]
  ! MULTIPLY        [ reduce using rule 32 (binop -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 32 (binop -> expr PLUS expr .) ]
  ! GT              [ reduce using rule 32 (binop -> expr PLUS expr .) ]
  ! LT              [ reduce using rule 32 (binop -> expr PLUS expr .) ]
  ! ET              [ reduce using rule 32 (binop -> expr PLUS expr .) ]
  ! GTE             [ reduce using rule 32 (binop -> expr PLUS expr .) ]
  ! LTE             [ reduce using rule 32 (binop -> expr PLUS expr .) ]
  ! NE              [ reduce using rule 32 (binop -> expr PLUS expr .) ]


state 78

    (33) binop -> expr MINUS expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 33 (binop -> expr MINUS expr .)
    IF              reduce using rule 33 (binop -> expr MINUS expr .)
    ASK             reduce using rule 33 (binop -> expr MINUS expr .)
    WHILE           reduce using rule 33 (binop -> expr MINUS expr .)
    PAUSE           reduce using rule 33 (binop -> expr MINUS expr .)
    FOREVER         reduce using rule 33 (binop -> expr MINUS expr .)
    EXIT            reduce using rule 33 (binop -> expr MINUS expr .)
    FUNCTION        reduce using rule 33 (binop -> expr MINUS expr .)
    RETURN          reduce using rule 33 (binop -> expr MINUS expr .)
    ID              reduce using rule 33 (binop -> expr MINUS expr .)
    SET             reduce using rule 33 (binop -> expr MINUS expr .)
    REPEAT          reduce using rule 33 (binop -> expr MINUS expr .)
    $end            reduce using rule 33 (binop -> expr MINUS expr .)
    END             reduce using rule 33 (binop -> expr MINUS expr .)
    THEN            reduce using rule 33 (binop -> expr MINUS expr .)
    WITH            reduce using rule 33 (binop -> expr MINUS expr .)
    CALL            reduce using rule 33 (binop -> expr MINUS expr .)
    DIGIT           reduce using rule 33 (binop -> expr MINUS expr .)
    LPAREN          reduce using rule 33 (binop -> expr MINUS expr .)
    RANDOM          reduce using rule 33 (binop -> expr MINUS expr .)
    TEXT            reduce using rule 33 (binop -> expr MINUS expr .)
    CONVERT         reduce using rule 33 (binop -> expr MINUS expr .)
    TIMES           reduce using rule 33 (binop -> expr MINUS expr .)
    RPAREN          reduce using rule 33 (binop -> expr MINUS expr .)
    TO              reduce using rule 33 (binop -> expr MINUS expr .)
    DO              reduce using rule 33 (binop -> expr MINUS expr .)
    MEANS           reduce using rule 33 (binop -> expr MINUS expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 33 (binop -> expr MINUS expr .) ]
  ! MINUS           [ reduce using rule 33 (binop -> expr MINUS expr .) ]
  ! MULTIPLY        [ reduce using rule 33 (binop -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 33 (binop -> expr MINUS expr .) ]
  ! GT              [ reduce using rule 33 (binop -> expr MINUS expr .) ]
  ! LT              [ reduce using rule 33 (binop -> expr MINUS expr .) ]
  ! ET              [ reduce using rule 33 (binop -> expr MINUS expr .) ]
  ! GTE             [ reduce using rule 33 (binop -> expr MINUS expr .) ]
  ! LTE             [ reduce using rule 33 (binop -> expr MINUS expr .) ]
  ! NE              [ reduce using rule 33 (binop -> expr MINUS expr .) ]


state 79

    (34) binop -> expr MULTIPLY expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 34 (binop -> expr MULTIPLY expr .)
    IF              reduce using rule 34 (binop -> expr MULTIPLY expr .)
    ASK             reduce using rule 34 (binop -> expr MULTIPLY expr .)
    WHILE           reduce using rule 34 (binop -> expr MULTIPLY expr .)
    PAUSE           reduce using rule 34 (binop -> expr MULTIPLY expr .)
    FOREVER         reduce using rule 34 (binop -> expr MULTIPLY expr .)
    EXIT            reduce using rule 34 (binop -> expr MULTIPLY expr .)
    FUNCTION        reduce using rule 34 (binop -> expr MULTIPLY expr .)
    RETURN          reduce using rule 34 (binop -> expr MULTIPLY expr .)
    ID              reduce using rule 34 (binop -> expr MULTIPLY expr .)
    SET             reduce using rule 34 (binop -> expr MULTIPLY expr .)
    REPEAT          reduce using rule 34 (binop -> expr MULTIPLY expr .)
    $end            reduce using rule 34 (binop -> expr MULTIPLY expr .)
    END             reduce using rule 34 (binop -> expr MULTIPLY expr .)
    THEN            reduce using rule 34 (binop -> expr MULTIPLY expr .)
    WITH            reduce using rule 34 (binop -> expr MULTIPLY expr .)
    CALL            reduce using rule 34 (binop -> expr MULTIPLY expr .)
    DIGIT           reduce using rule 34 (binop -> expr MULTIPLY expr .)
    LPAREN          reduce using rule 34 (binop -> expr MULTIPLY expr .)
    RANDOM          reduce using rule 34 (binop -> expr MULTIPLY expr .)
    TEXT            reduce using rule 34 (binop -> expr MULTIPLY expr .)
    CONVERT         reduce using rule 34 (binop -> expr MULTIPLY expr .)
    TIMES           reduce using rule 34 (binop -> expr MULTIPLY expr .)
    RPAREN          reduce using rule 34 (binop -> expr MULTIPLY expr .)
    TO              reduce using rule 34 (binop -> expr MULTIPLY expr .)
    DO              reduce using rule 34 (binop -> expr MULTIPLY expr .)
    MEANS           reduce using rule 34 (binop -> expr MULTIPLY expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 34 (binop -> expr MULTIPLY expr .) ]
  ! MINUS           [ reduce using rule 34 (binop -> expr MULTIPLY expr .) ]
  ! MULTIPLY        [ reduce using rule 34 (binop -> expr MULTIPLY expr .) ]
  ! DIVIDE          [ reduce using rule 34 (binop -> expr MULTIPLY expr .) ]
  ! GT              [ reduce using rule 34 (binop -> expr MULTIPLY expr .) ]
  ! LT              [ reduce using rule 34 (binop -> expr MULTIPLY expr .) ]
  ! ET              [ reduce using rule 34 (binop -> expr MULTIPLY expr .) ]
  ! GTE             [ reduce using rule 34 (binop -> expr MULTIPLY expr .) ]
  ! LTE             [ reduce using rule 34 (binop -> expr MULTIPLY expr .) ]
  ! NE              [ reduce using rule 34 (binop -> expr MULTIPLY expr .) ]


state 80

    (35) binop -> expr DIVIDE expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 35 (binop -> expr DIVIDE expr .)
    IF              reduce using rule 35 (binop -> expr DIVIDE expr .)
    ASK             reduce using rule 35 (binop -> expr DIVIDE expr .)
    WHILE           reduce using rule 35 (binop -> expr DIVIDE expr .)
    PAUSE           reduce using rule 35 (binop -> expr DIVIDE expr .)
    FOREVER         reduce using rule 35 (binop -> expr DIVIDE expr .)
    EXIT            reduce using rule 35 (binop -> expr DIVIDE expr .)
    FUNCTION        reduce using rule 35 (binop -> expr DIVIDE expr .)
    RETURN          reduce using rule 35 (binop -> expr DIVIDE expr .)
    ID              reduce using rule 35 (binop -> expr DIVIDE expr .)
    SET             reduce using rule 35 (binop -> expr DIVIDE expr .)
    REPEAT          reduce using rule 35 (binop -> expr DIVIDE expr .)
    $end            reduce using rule 35 (binop -> expr DIVIDE expr .)
    END             reduce using rule 35 (binop -> expr DIVIDE expr .)
    THEN            reduce using rule 35 (binop -> expr DIVIDE expr .)
    WITH            reduce using rule 35 (binop -> expr DIVIDE expr .)
    CALL            reduce using rule 35 (binop -> expr DIVIDE expr .)
    DIGIT           reduce using rule 35 (binop -> expr DIVIDE expr .)
    LPAREN          reduce using rule 35 (binop -> expr DIVIDE expr .)
    RANDOM          reduce using rule 35 (binop -> expr DIVIDE expr .)
    TEXT            reduce using rule 35 (binop -> expr DIVIDE expr .)
    CONVERT         reduce using rule 35 (binop -> expr DIVIDE expr .)
    TIMES           reduce using rule 35 (binop -> expr DIVIDE expr .)
    RPAREN          reduce using rule 35 (binop -> expr DIVIDE expr .)
    TO              reduce using rule 35 (binop -> expr DIVIDE expr .)
    DO              reduce using rule 35 (binop -> expr DIVIDE expr .)
    MEANS           reduce using rule 35 (binop -> expr DIVIDE expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 35 (binop -> expr DIVIDE expr .) ]
  ! MINUS           [ reduce using rule 35 (binop -> expr DIVIDE expr .) ]
  ! MULTIPLY        [ reduce using rule 35 (binop -> expr DIVIDE expr .) ]
  ! DIVIDE          [ reduce using rule 35 (binop -> expr DIVIDE expr .) ]
  ! GT              [ reduce using rule 35 (binop -> expr DIVIDE expr .) ]
  ! LT              [ reduce using rule 35 (binop -> expr DIVIDE expr .) ]
  ! ET              [ reduce using rule 35 (binop -> expr DIVIDE expr .) ]
  ! GTE             [ reduce using rule 35 (binop -> expr DIVIDE expr .) ]
  ! LTE             [ reduce using rule 35 (binop -> expr DIVIDE expr .) ]
  ! NE              [ reduce using rule 35 (binop -> expr DIVIDE expr .) ]


state 81

    (36) condition -> expr GT expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 36 (condition -> expr GT expr .)
    IF              reduce using rule 36 (condition -> expr GT expr .)
    ASK             reduce using rule 36 (condition -> expr GT expr .)
    WHILE           reduce using rule 36 (condition -> expr GT expr .)
    PAUSE           reduce using rule 36 (condition -> expr GT expr .)
    FOREVER         reduce using rule 36 (condition -> expr GT expr .)
    EXIT            reduce using rule 36 (condition -> expr GT expr .)
    FUNCTION        reduce using rule 36 (condition -> expr GT expr .)
    RETURN          reduce using rule 36 (condition -> expr GT expr .)
    ID              reduce using rule 36 (condition -> expr GT expr .)
    SET             reduce using rule 36 (condition -> expr GT expr .)
    REPEAT          reduce using rule 36 (condition -> expr GT expr .)
    $end            reduce using rule 36 (condition -> expr GT expr .)
    END             reduce using rule 36 (condition -> expr GT expr .)
    THEN            reduce using rule 36 (condition -> expr GT expr .)
    DO              reduce using rule 36 (condition -> expr GT expr .)
    WITH            reduce using rule 36 (condition -> expr GT expr .)
    CALL            reduce using rule 36 (condition -> expr GT expr .)
    DIGIT           reduce using rule 36 (condition -> expr GT expr .)
    LPAREN          reduce using rule 36 (condition -> expr GT expr .)
    RANDOM          reduce using rule 36 (condition -> expr GT expr .)
    TEXT            reduce using rule 36 (condition -> expr GT expr .)
    CONVERT         reduce using rule 36 (condition -> expr GT expr .)
    TIMES           reduce using rule 36 (condition -> expr GT expr .)
    RPAREN          reduce using rule 36 (condition -> expr GT expr .)
    TO              reduce using rule 36 (condition -> expr GT expr .)
    MEANS           reduce using rule 36 (condition -> expr GT expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 36 (condition -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 36 (condition -> expr GT expr .) ]
  ! MULTIPLY        [ reduce using rule 36 (condition -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 36 (condition -> expr GT expr .) ]
  ! GT              [ reduce using rule 36 (condition -> expr GT expr .) ]
  ! LT              [ reduce using rule 36 (condition -> expr GT expr .) ]
  ! ET              [ reduce using rule 36 (condition -> expr GT expr .) ]
  ! GTE             [ reduce using rule 36 (condition -> expr GT expr .) ]
  ! LTE             [ reduce using rule 36 (condition -> expr GT expr .) ]
  ! NE              [ reduce using rule 36 (condition -> expr GT expr .) ]


state 82

    (37) condition -> expr LT expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 37 (condition -> expr LT expr .)
    IF              reduce using rule 37 (condition -> expr LT expr .)
    ASK             reduce using rule 37 (condition -> expr LT expr .)
    WHILE           reduce using rule 37 (condition -> expr LT expr .)
    PAUSE           reduce using rule 37 (condition -> expr LT expr .)
    FOREVER         reduce using rule 37 (condition -> expr LT expr .)
    EXIT            reduce using rule 37 (condition -> expr LT expr .)
    FUNCTION        reduce using rule 37 (condition -> expr LT expr .)
    RETURN          reduce using rule 37 (condition -> expr LT expr .)
    ID              reduce using rule 37 (condition -> expr LT expr .)
    SET             reduce using rule 37 (condition -> expr LT expr .)
    REPEAT          reduce using rule 37 (condition -> expr LT expr .)
    $end            reduce using rule 37 (condition -> expr LT expr .)
    END             reduce using rule 37 (condition -> expr LT expr .)
    THEN            reduce using rule 37 (condition -> expr LT expr .)
    DO              reduce using rule 37 (condition -> expr LT expr .)
    WITH            reduce using rule 37 (condition -> expr LT expr .)
    CALL            reduce using rule 37 (condition -> expr LT expr .)
    DIGIT           reduce using rule 37 (condition -> expr LT expr .)
    LPAREN          reduce using rule 37 (condition -> expr LT expr .)
    RANDOM          reduce using rule 37 (condition -> expr LT expr .)
    TEXT            reduce using rule 37 (condition -> expr LT expr .)
    CONVERT         reduce using rule 37 (condition -> expr LT expr .)
    TIMES           reduce using rule 37 (condition -> expr LT expr .)
    RPAREN          reduce using rule 37 (condition -> expr LT expr .)
    TO              reduce using rule 37 (condition -> expr LT expr .)
    MEANS           reduce using rule 37 (condition -> expr LT expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 37 (condition -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 37 (condition -> expr LT expr .) ]
  ! MULTIPLY        [ reduce using rule 37 (condition -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 37 (condition -> expr LT expr .) ]
  ! GT              [ reduce using rule 37 (condition -> expr LT expr .) ]
  ! LT              [ reduce using rule 37 (condition -> expr LT expr .) ]
  ! ET              [ reduce using rule 37 (condition -> expr LT expr .) ]
  ! GTE             [ reduce using rule 37 (condition -> expr LT expr .) ]
  ! LTE             [ reduce using rule 37 (condition -> expr LT expr .) ]
  ! NE              [ reduce using rule 37 (condition -> expr LT expr .) ]


state 83

    (38) condition -> expr ET expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 38 (condition -> expr ET expr .)
    IF              reduce using rule 38 (condition -> expr ET expr .)
    ASK             reduce using rule 38 (condition -> expr ET expr .)
    WHILE           reduce using rule 38 (condition -> expr ET expr .)
    PAUSE           reduce using rule 38 (condition -> expr ET expr .)
    FOREVER         reduce using rule 38 (condition -> expr ET expr .)
    EXIT            reduce using rule 38 (condition -> expr ET expr .)
    FUNCTION        reduce using rule 38 (condition -> expr ET expr .)
    RETURN          reduce using rule 38 (condition -> expr ET expr .)
    ID              reduce using rule 38 (condition -> expr ET expr .)
    SET             reduce using rule 38 (condition -> expr ET expr .)
    REPEAT          reduce using rule 38 (condition -> expr ET expr .)
    $end            reduce using rule 38 (condition -> expr ET expr .)
    END             reduce using rule 38 (condition -> expr ET expr .)
    THEN            reduce using rule 38 (condition -> expr ET expr .)
    DO              reduce using rule 38 (condition -> expr ET expr .)
    WITH            reduce using rule 38 (condition -> expr ET expr .)
    CALL            reduce using rule 38 (condition -> expr ET expr .)
    DIGIT           reduce using rule 38 (condition -> expr ET expr .)
    LPAREN          reduce using rule 38 (condition -> expr ET expr .)
    RANDOM          reduce using rule 38 (condition -> expr ET expr .)
    TEXT            reduce using rule 38 (condition -> expr ET expr .)
    CONVERT         reduce using rule 38 (condition -> expr ET expr .)
    TIMES           reduce using rule 38 (condition -> expr ET expr .)
    RPAREN          reduce using rule 38 (condition -> expr ET expr .)
    TO              reduce using rule 38 (condition -> expr ET expr .)
    MEANS           reduce using rule 38 (condition -> expr ET expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 38 (condition -> expr ET expr .) ]
  ! MINUS           [ reduce using rule 38 (condition -> expr ET expr .) ]
  ! MULTIPLY        [ reduce using rule 38 (condition -> expr ET expr .) ]
  ! DIVIDE          [ reduce using rule 38 (condition -> expr ET expr .) ]
  ! GT              [ reduce using rule 38 (condition -> expr ET expr .) ]
  ! LT              [ reduce using rule 38 (condition -> expr ET expr .) ]
  ! ET              [ reduce using rule 38 (condition -> expr ET expr .) ]
  ! GTE             [ reduce using rule 38 (condition -> expr ET expr .) ]
  ! LTE             [ reduce using rule 38 (condition -> expr ET expr .) ]
  ! NE              [ reduce using rule 38 (condition -> expr ET expr .) ]


state 84

    (39) condition -> expr GTE expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 39 (condition -> expr GTE expr .)
    IF              reduce using rule 39 (condition -> expr GTE expr .)
    ASK             reduce using rule 39 (condition -> expr GTE expr .)
    WHILE           reduce using rule 39 (condition -> expr GTE expr .)
    PAUSE           reduce using rule 39 (condition -> expr GTE expr .)
    FOREVER         reduce using rule 39 (condition -> expr GTE expr .)
    EXIT            reduce using rule 39 (condition -> expr GTE expr .)
    FUNCTION        reduce using rule 39 (condition -> expr GTE expr .)
    RETURN          reduce using rule 39 (condition -> expr GTE expr .)
    ID              reduce using rule 39 (condition -> expr GTE expr .)
    SET             reduce using rule 39 (condition -> expr GTE expr .)
    REPEAT          reduce using rule 39 (condition -> expr GTE expr .)
    $end            reduce using rule 39 (condition -> expr GTE expr .)
    END             reduce using rule 39 (condition -> expr GTE expr .)
    THEN            reduce using rule 39 (condition -> expr GTE expr .)
    DO              reduce using rule 39 (condition -> expr GTE expr .)
    WITH            reduce using rule 39 (condition -> expr GTE expr .)
    CALL            reduce using rule 39 (condition -> expr GTE expr .)
    DIGIT           reduce using rule 39 (condition -> expr GTE expr .)
    LPAREN          reduce using rule 39 (condition -> expr GTE expr .)
    RANDOM          reduce using rule 39 (condition -> expr GTE expr .)
    TEXT            reduce using rule 39 (condition -> expr GTE expr .)
    CONVERT         reduce using rule 39 (condition -> expr GTE expr .)
    TIMES           reduce using rule 39 (condition -> expr GTE expr .)
    RPAREN          reduce using rule 39 (condition -> expr GTE expr .)
    TO              reduce using rule 39 (condition -> expr GTE expr .)
    MEANS           reduce using rule 39 (condition -> expr GTE expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 39 (condition -> expr GTE expr .) ]
  ! MINUS           [ reduce using rule 39 (condition -> expr GTE expr .) ]
  ! MULTIPLY        [ reduce using rule 39 (condition -> expr GTE expr .) ]
  ! DIVIDE          [ reduce using rule 39 (condition -> expr GTE expr .) ]
  ! GT              [ reduce using rule 39 (condition -> expr GTE expr .) ]
  ! LT              [ reduce using rule 39 (condition -> expr GTE expr .) ]
  ! ET              [ reduce using rule 39 (condition -> expr GTE expr .) ]
  ! GTE             [ reduce using rule 39 (condition -> expr GTE expr .) ]
  ! LTE             [ reduce using rule 39 (condition -> expr GTE expr .) ]
  ! NE              [ reduce using rule 39 (condition -> expr GTE expr .) ]


state 85

    (40) condition -> expr LTE expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 40 (condition -> expr LTE expr .)
    IF              reduce using rule 40 (condition -> expr LTE expr .)
    ASK             reduce using rule 40 (condition -> expr LTE expr .)
    WHILE           reduce using rule 40 (condition -> expr LTE expr .)
    PAUSE           reduce using rule 40 (condition -> expr LTE expr .)
    FOREVER         reduce using rule 40 (condition -> expr LTE expr .)
    EXIT            reduce using rule 40 (condition -> expr LTE expr .)
    FUNCTION        reduce using rule 40 (condition -> expr LTE expr .)
    RETURN          reduce using rule 40 (condition -> expr LTE expr .)
    ID              reduce using rule 40 (condition -> expr LTE expr .)
    SET             reduce using rule 40 (condition -> expr LTE expr .)
    REPEAT          reduce using rule 40 (condition -> expr LTE expr .)
    $end            reduce using rule 40 (condition -> expr LTE expr .)
    END             reduce using rule 40 (condition -> expr LTE expr .)
    THEN            reduce using rule 40 (condition -> expr LTE expr .)
    DO              reduce using rule 40 (condition -> expr LTE expr .)
    WITH            reduce using rule 40 (condition -> expr LTE expr .)
    CALL            reduce using rule 40 (condition -> expr LTE expr .)
    DIGIT           reduce using rule 40 (condition -> expr LTE expr .)
    LPAREN          reduce using rule 40 (condition -> expr LTE expr .)
    RANDOM          reduce using rule 40 (condition -> expr LTE expr .)
    TEXT            reduce using rule 40 (condition -> expr LTE expr .)
    CONVERT         reduce using rule 40 (condition -> expr LTE expr .)
    TIMES           reduce using rule 40 (condition -> expr LTE expr .)
    RPAREN          reduce using rule 40 (condition -> expr LTE expr .)
    TO              reduce using rule 40 (condition -> expr LTE expr .)
    MEANS           reduce using rule 40 (condition -> expr LTE expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 40 (condition -> expr LTE expr .) ]
  ! MINUS           [ reduce using rule 40 (condition -> expr LTE expr .) ]
  ! MULTIPLY        [ reduce using rule 40 (condition -> expr LTE expr .) ]
  ! DIVIDE          [ reduce using rule 40 (condition -> expr LTE expr .) ]
  ! GT              [ reduce using rule 40 (condition -> expr LTE expr .) ]
  ! LT              [ reduce using rule 40 (condition -> expr LTE expr .) ]
  ! ET              [ reduce using rule 40 (condition -> expr LTE expr .) ]
  ! GTE             [ reduce using rule 40 (condition -> expr LTE expr .) ]
  ! LTE             [ reduce using rule 40 (condition -> expr LTE expr .) ]
  ! NE              [ reduce using rule 40 (condition -> expr LTE expr .) ]


state 86

    (41) condition -> expr NE expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 41 (condition -> expr NE expr .)
    IF              reduce using rule 41 (condition -> expr NE expr .)
    ASK             reduce using rule 41 (condition -> expr NE expr .)
    WHILE           reduce using rule 41 (condition -> expr NE expr .)
    PAUSE           reduce using rule 41 (condition -> expr NE expr .)
    FOREVER         reduce using rule 41 (condition -> expr NE expr .)
    EXIT            reduce using rule 41 (condition -> expr NE expr .)
    FUNCTION        reduce using rule 41 (condition -> expr NE expr .)
    RETURN          reduce using rule 41 (condition -> expr NE expr .)
    ID              reduce using rule 41 (condition -> expr NE expr .)
    SET             reduce using rule 41 (condition -> expr NE expr .)
    REPEAT          reduce using rule 41 (condition -> expr NE expr .)
    $end            reduce using rule 41 (condition -> expr NE expr .)
    END             reduce using rule 41 (condition -> expr NE expr .)
    THEN            reduce using rule 41 (condition -> expr NE expr .)
    DO              reduce using rule 41 (condition -> expr NE expr .)
    WITH            reduce using rule 41 (condition -> expr NE expr .)
    CALL            reduce using rule 41 (condition -> expr NE expr .)
    DIGIT           reduce using rule 41 (condition -> expr NE expr .)
    LPAREN          reduce using rule 41 (condition -> expr NE expr .)
    RANDOM          reduce using rule 41 (condition -> expr NE expr .)
    TEXT            reduce using rule 41 (condition -> expr NE expr .)
    CONVERT         reduce using rule 41 (condition -> expr NE expr .)
    TIMES           reduce using rule 41 (condition -> expr NE expr .)
    RPAREN          reduce using rule 41 (condition -> expr NE expr .)
    TO              reduce using rule 41 (condition -> expr NE expr .)
    MEANS           reduce using rule 41 (condition -> expr NE expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 41 (condition -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 41 (condition -> expr NE expr .) ]
  ! MULTIPLY        [ reduce using rule 41 (condition -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 41 (condition -> expr NE expr .) ]
  ! GT              [ reduce using rule 41 (condition -> expr NE expr .) ]
  ! LT              [ reduce using rule 41 (condition -> expr NE expr .) ]
  ! ET              [ reduce using rule 41 (condition -> expr NE expr .) ]
  ! GTE             [ reduce using rule 41 (condition -> expr NE expr .) ]
  ! LTE             [ reduce using rule 41 (condition -> expr NE expr .) ]
  ! NE              [ reduce using rule 41 (condition -> expr NE expr .) ]


state 87

    (31) expr -> CALL expr params .
    (51) params -> params . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for DIGIT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for RANDOM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for CONVERT resolved as shift
    PLUS            reduce using rule 31 (expr -> CALL expr params .)
    MINUS           reduce using rule 31 (expr -> CALL expr params .)
    MULTIPLY        reduce using rule 31 (expr -> CALL expr params .)
    DIVIDE          reduce using rule 31 (expr -> CALL expr params .)
    GT              reduce using rule 31 (expr -> CALL expr params .)
    LT              reduce using rule 31 (expr -> CALL expr params .)
    ET              reduce using rule 31 (expr -> CALL expr params .)
    GTE             reduce using rule 31 (expr -> CALL expr params .)
    LTE             reduce using rule 31 (expr -> CALL expr params .)
    NE              reduce using rule 31 (expr -> CALL expr params .)
    OUTPUT          reduce using rule 31 (expr -> CALL expr params .)
    IF              reduce using rule 31 (expr -> CALL expr params .)
    ASK             reduce using rule 31 (expr -> CALL expr params .)
    WHILE           reduce using rule 31 (expr -> CALL expr params .)
    PAUSE           reduce using rule 31 (expr -> CALL expr params .)
    FOREVER         reduce using rule 31 (expr -> CALL expr params .)
    EXIT            reduce using rule 31 (expr -> CALL expr params .)
    FUNCTION        reduce using rule 31 (expr -> CALL expr params .)
    RETURN          reduce using rule 31 (expr -> CALL expr params .)
    SET             reduce using rule 31 (expr -> CALL expr params .)
    REPEAT          reduce using rule 31 (expr -> CALL expr params .)
    $end            reduce using rule 31 (expr -> CALL expr params .)
    END             reduce using rule 31 (expr -> CALL expr params .)
    THEN            reduce using rule 31 (expr -> CALL expr params .)
    WITH            reduce using rule 31 (expr -> CALL expr params .)
    TIMES           reduce using rule 31 (expr -> CALL expr params .)
    RPAREN          reduce using rule 31 (expr -> CALL expr params .)
    TO              reduce using rule 31 (expr -> CALL expr params .)
    DO              reduce using rule 31 (expr -> CALL expr params .)
    MEANS           reduce using rule 31 (expr -> CALL expr params .)
    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

  ! ID              [ reduce using rule 31 (expr -> CALL expr params .) ]
  ! CALL            [ reduce using rule 31 (expr -> CALL expr params .) ]
  ! DIGIT           [ reduce using rule 31 (expr -> CALL expr params .) ]
  ! LPAREN          [ reduce using rule 31 (expr -> CALL expr params .) ]
  ! RANDOM          [ reduce using rule 31 (expr -> CALL expr params .) ]
  ! TEXT            [ reduce using rule 31 (expr -> CALL expr params .) ]
  ! CONVERT         [ reduce using rule 31 (expr -> CALL expr params .) ]

    expr                           shift and go to state 75
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 88

    (44) expr -> LPAREN expr RPAREN .

    PLUS            reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    MULTIPLY        reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    ET              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    GTE             reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    LTE             reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    OUTPUT          reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    IF              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    ASK             reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    WHILE           reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    PAUSE           reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    FOREVER         reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    EXIT            reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    FUNCTION        reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    ID              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    SET             reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    REPEAT          reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    END             reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    THEN            reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    WITH            reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    CALL            reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    DIGIT           reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    RANDOM          reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    TEXT            reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    CONVERT         reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    TO              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    DO              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    MEANS           reduce using rule 44 (expr -> LPAREN expr RPAREN .)


state 89

    (45) expr -> RANDOM NUMBER FROM . expr TO expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 96
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 90

    (47) expr -> CONVERT expr TO . datatype
    (48) datatype -> . NUM
    (49) datatype -> . TXT

    NUM             shift and go to state 98
    TXT             shift and go to state 99

    datatype                       shift and go to state 97

state 91

    (18) if_then_stmt -> IF expr THEN body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 100
    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    stmt                           shift and go to state 29
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15
    repeat                         shift and go to state 20

state 92

    (20) while_stmt -> WHILE condition DO body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 101
    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    stmt                           shift and go to state 29
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15
    repeat                         shift and go to state 20

state 93

    (24) forever_stmt -> FOREVER DO body END .

    OUTPUT          reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    IF              reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    ASK             reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    WHILE           reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    PAUSE           reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    FOREVER         reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    EXIT            reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    FUNCTION        reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    RETURN          reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    ID              reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    SET             reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    REPEAT          reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    $end            reduce using rule 24 (forever_stmt -> FOREVER DO body END .)
    END             reduce using rule 24 (forever_stmt -> FOREVER DO body END .)


state 94

    (26) function_stmt -> FUNCTION expr WITH params . MEANS body END
    (51) params -> params . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    MEANS           shift and go to state 102
    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 75
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 95

    (21) repeat -> REPEAT expr TIMES USING . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 103
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 96

    (45) expr -> RANDOM NUMBER FROM expr . TO expr
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    TO              shift and go to state 104
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 97

    (47) expr -> CONVERT expr TO datatype .

    PLUS            reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    MINUS           reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    MULTIPLY        reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    DIVIDE          reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    GT              reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    LT              reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    ET              reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    GTE             reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    LTE             reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    NE              reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    OUTPUT          reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    IF              reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    ASK             reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    WHILE           reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    PAUSE           reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    FOREVER         reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    EXIT            reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    FUNCTION        reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    RETURN          reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    ID              reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    SET             reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    REPEAT          reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    $end            reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    END             reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    THEN            reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    WITH            reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    CALL            reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    DIGIT           reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    LPAREN          reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    RANDOM          reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    TEXT            reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    CONVERT         reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    TIMES           reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    RPAREN          reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    TO              reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    DO              reduce using rule 47 (expr -> CONVERT expr TO datatype .)
    MEANS           reduce using rule 47 (expr -> CONVERT expr TO datatype .)


state 98

    (48) datatype -> NUM .

    PLUS            reduce using rule 48 (datatype -> NUM .)
    MINUS           reduce using rule 48 (datatype -> NUM .)
    MULTIPLY        reduce using rule 48 (datatype -> NUM .)
    DIVIDE          reduce using rule 48 (datatype -> NUM .)
    GT              reduce using rule 48 (datatype -> NUM .)
    LT              reduce using rule 48 (datatype -> NUM .)
    ET              reduce using rule 48 (datatype -> NUM .)
    GTE             reduce using rule 48 (datatype -> NUM .)
    LTE             reduce using rule 48 (datatype -> NUM .)
    NE              reduce using rule 48 (datatype -> NUM .)
    OUTPUT          reduce using rule 48 (datatype -> NUM .)
    IF              reduce using rule 48 (datatype -> NUM .)
    ASK             reduce using rule 48 (datatype -> NUM .)
    WHILE           reduce using rule 48 (datatype -> NUM .)
    PAUSE           reduce using rule 48 (datatype -> NUM .)
    FOREVER         reduce using rule 48 (datatype -> NUM .)
    EXIT            reduce using rule 48 (datatype -> NUM .)
    FUNCTION        reduce using rule 48 (datatype -> NUM .)
    RETURN          reduce using rule 48 (datatype -> NUM .)
    ID              reduce using rule 48 (datatype -> NUM .)
    SET             reduce using rule 48 (datatype -> NUM .)
    REPEAT          reduce using rule 48 (datatype -> NUM .)
    $end            reduce using rule 48 (datatype -> NUM .)
    END             reduce using rule 48 (datatype -> NUM .)
    THEN            reduce using rule 48 (datatype -> NUM .)
    WITH            reduce using rule 48 (datatype -> NUM .)
    CALL            reduce using rule 48 (datatype -> NUM .)
    DIGIT           reduce using rule 48 (datatype -> NUM .)
    LPAREN          reduce using rule 48 (datatype -> NUM .)
    RANDOM          reduce using rule 48 (datatype -> NUM .)
    TEXT            reduce using rule 48 (datatype -> NUM .)
    CONVERT         reduce using rule 48 (datatype -> NUM .)
    TIMES           reduce using rule 48 (datatype -> NUM .)
    RPAREN          reduce using rule 48 (datatype -> NUM .)
    TO              reduce using rule 48 (datatype -> NUM .)
    DO              reduce using rule 48 (datatype -> NUM .)
    MEANS           reduce using rule 48 (datatype -> NUM .)


state 99

    (49) datatype -> TXT .

    PLUS            reduce using rule 49 (datatype -> TXT .)
    MINUS           reduce using rule 49 (datatype -> TXT .)
    MULTIPLY        reduce using rule 49 (datatype -> TXT .)
    DIVIDE          reduce using rule 49 (datatype -> TXT .)
    GT              reduce using rule 49 (datatype -> TXT .)
    LT              reduce using rule 49 (datatype -> TXT .)
    ET              reduce using rule 49 (datatype -> TXT .)
    GTE             reduce using rule 49 (datatype -> TXT .)
    LTE             reduce using rule 49 (datatype -> TXT .)
    NE              reduce using rule 49 (datatype -> TXT .)
    OUTPUT          reduce using rule 49 (datatype -> TXT .)
    IF              reduce using rule 49 (datatype -> TXT .)
    ASK             reduce using rule 49 (datatype -> TXT .)
    WHILE           reduce using rule 49 (datatype -> TXT .)
    PAUSE           reduce using rule 49 (datatype -> TXT .)
    FOREVER         reduce using rule 49 (datatype -> TXT .)
    EXIT            reduce using rule 49 (datatype -> TXT .)
    FUNCTION        reduce using rule 49 (datatype -> TXT .)
    RETURN          reduce using rule 49 (datatype -> TXT .)
    ID              reduce using rule 49 (datatype -> TXT .)
    SET             reduce using rule 49 (datatype -> TXT .)
    REPEAT          reduce using rule 49 (datatype -> TXT .)
    $end            reduce using rule 49 (datatype -> TXT .)
    END             reduce using rule 49 (datatype -> TXT .)
    THEN            reduce using rule 49 (datatype -> TXT .)
    WITH            reduce using rule 49 (datatype -> TXT .)
    CALL            reduce using rule 49 (datatype -> TXT .)
    DIGIT           reduce using rule 49 (datatype -> TXT .)
    LPAREN          reduce using rule 49 (datatype -> TXT .)
    RANDOM          reduce using rule 49 (datatype -> TXT .)
    TEXT            reduce using rule 49 (datatype -> TXT .)
    CONVERT         reduce using rule 49 (datatype -> TXT .)
    TIMES           reduce using rule 49 (datatype -> TXT .)
    RPAREN          reduce using rule 49 (datatype -> TXT .)
    TO              reduce using rule 49 (datatype -> TXT .)
    DO              reduce using rule 49 (datatype -> TXT .)
    MEANS           reduce using rule 49 (datatype -> TXT .)


state 100

    (18) if_then_stmt -> IF expr THEN body END .

    OUTPUT          reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    IF              reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    ASK             reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    WHILE           reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    PAUSE           reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    FOREVER         reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    EXIT            reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    FUNCTION        reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    RETURN          reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    ID              reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    SET             reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    REPEAT          reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    $end            reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)
    END             reduce using rule 18 (if_then_stmt -> IF expr THEN body END .)


state 101

    (20) while_stmt -> WHILE condition DO body END .

    OUTPUT          reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    IF              reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    ASK             reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    WHILE           reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    PAUSE           reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    FOREVER         reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    EXIT            reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    FUNCTION        reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    RETURN          reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    ID              reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    SET             reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    REPEAT          reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    $end            reduce using rule 20 (while_stmt -> WHILE condition DO body END .)
    END             reduce using rule 20 (while_stmt -> WHILE condition DO body END .)


state 102

    (26) function_stmt -> FUNCTION expr WITH params MEANS . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    body                           shift and go to state 105
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15
    repeat                         shift and go to state 20

state 103

    (21) repeat -> REPEAT expr TIMES USING expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

    OUTPUT          reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    IF              reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    ASK             reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    WHILE           reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    PAUSE           reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    FOREVER         reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    EXIT            reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    FUNCTION        reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    RETURN          reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    ID              reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    SET             reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    REPEAT          reduce using rule 21 (repeat -> REPEAT expr TIMES USING expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65


state 104

    (45) expr -> RANDOM NUMBER FROM expr TO . expr
    (29) expr -> . binop
    (30) expr -> . condition
    (31) expr -> . CALL expr params
    (42) expr -> . DIGIT
    (43) expr -> . ID
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . RANDOM NUMBER FROM expr TO expr
    (46) expr -> . TEXT
    (47) expr -> . CONVERT expr TO datatype
    (32) binop -> . expr PLUS expr
    (33) binop -> . expr MINUS expr
    (34) binop -> . expr MULTIPLY expr
    (35) binop -> . expr DIVIDE expr
    (36) condition -> . expr GT expr
    (37) condition -> . expr LT expr
    (38) condition -> . expr ET expr
    (39) condition -> . expr GTE expr
    (40) condition -> . expr LTE expr
    (41) condition -> . expr NE expr

    CALL            shift and go to state 34
    DIGIT           shift and go to state 35
    ID              shift and go to state 36
    LPAREN          shift and go to state 37
    RANDOM          shift and go to state 38
    TEXT            shift and go to state 39
    CONVERT         shift and go to state 40

    expr                           shift and go to state 106
    binop                          shift and go to state 32
    condition                      shift and go to state 33

state 105

    (26) function_stmt -> FUNCTION expr WITH params MEANS body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (10) stmt -> . forever_stmt
    (11) stmt -> . exit_stmt
    (12) stmt -> . function_stmt
    (13) stmt -> . return_stmt
    (14) stmt -> . call_stmt
    (16) set_stmt -> . var_stmt TO expr
    (17) output_stmt -> . OUTPUT expr
    (18) if_then_stmt -> . IF expr THEN body END
    (19) input_stmt -> . ASK expr
    (20) while_stmt -> . WHILE condition DO body END
    (22) repeat_stmt -> . repeat body END
    (23) pause_stmt -> . PAUSE expr
    (24) forever_stmt -> . FOREVER DO body END
    (25) exit_stmt -> . EXIT LOOP
    (26) function_stmt -> . FUNCTION expr WITH params MEANS body END
    (27) return_stmt -> . RETURN expr
    (28) call_stmt -> . ID params
    (15) var_stmt -> . SET ID
    (21) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 107
    OUTPUT          shift and go to state 16
    IF              shift and go to state 17
    ASK             shift and go to state 18
    WHILE           shift and go to state 19
    PAUSE           shift and go to state 21
    FOREVER         shift and go to state 22
    EXIT            shift and go to state 23
    FUNCTION        shift and go to state 24
    RETURN          shift and go to state 25
    ID              shift and go to state 26
    SET             shift and go to state 27
    REPEAT          shift and go to state 28

    stmt                           shift and go to state 29
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    forever_stmt                   shift and go to state 10
    exit_stmt                      shift and go to state 11
    function_stmt                  shift and go to state 12
    return_stmt                    shift and go to state 13
    call_stmt                      shift and go to state 14
    var_stmt                       shift and go to state 15
    repeat                         shift and go to state 20

state 106

    (45) expr -> RANDOM NUMBER FROM expr TO expr .
    (32) binop -> expr . PLUS expr
    (33) binop -> expr . MINUS expr
    (34) binop -> expr . MULTIPLY expr
    (35) binop -> expr . DIVIDE expr
    (36) condition -> expr . GT expr
    (37) condition -> expr . LT expr
    (38) condition -> expr . ET expr
    (39) condition -> expr . GTE expr
    (40) condition -> expr . LTE expr
    (41) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    IF              reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    ASK             reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    WHILE           reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    PAUSE           reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    FOREVER         reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    EXIT            reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    FUNCTION        reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    RETURN          reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    ID              reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    SET             reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    REPEAT          reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    $end            reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    END             reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    THEN            reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    WITH            reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    CALL            reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    DIGIT           reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    LPAREN          reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    RANDOM          reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    TEXT            reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    CONVERT         reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    TIMES           reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    RPAREN          reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    TO              reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    DO              reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    MEANS           reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    MULTIPLY        shift and go to state 58
    DIVIDE          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    ET              shift and go to state 62
    GTE             shift and go to state 63
    LTE             shift and go to state 64
    NE              shift and go to state 65

  ! PLUS            [ reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! MINUS           [ reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! MULTIPLY        [ reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! DIVIDE          [ reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! GT              [ reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! LT              [ reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! ET              [ reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! GTE             [ reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! LTE             [ reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! NE              [ reduce using rule 45 (expr -> RANDOM NUMBER FROM expr TO expr .) ]


state 107

    (26) function_stmt -> FUNCTION expr WITH params MEANS body END .

    OUTPUT          reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    IF              reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    ASK             reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    WHILE           reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    PAUSE           reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    FOREVER         reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    EXIT            reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    FUNCTION        reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    RETURN          reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    ID              reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    SET             reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    REPEAT          reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    $end            reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)
    END             reduce using rule 26 (function_stmt -> FUNCTION expr WITH params MEANS body END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 51 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 52 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 52 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 52 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 52 resolved as shift
WARNING: shift/reduce conflict for GT in state 52 resolved as shift
WARNING: shift/reduce conflict for LT in state 52 resolved as shift
WARNING: shift/reduce conflict for ET in state 52 resolved as shift
WARNING: shift/reduce conflict for GTE in state 52 resolved as shift
WARNING: shift/reduce conflict for LTE in state 52 resolved as shift
WARNING: shift/reduce conflict for NE in state 52 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 75 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 75 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 75 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 75 resolved as shift
WARNING: shift/reduce conflict for GT in state 75 resolved as shift
WARNING: shift/reduce conflict for LT in state 75 resolved as shift
WARNING: shift/reduce conflict for ET in state 75 resolved as shift
WARNING: shift/reduce conflict for GTE in state 75 resolved as shift
WARNING: shift/reduce conflict for LTE in state 75 resolved as shift
WARNING: shift/reduce conflict for NE in state 75 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 77 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 77 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 77 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 77 resolved as shift
WARNING: shift/reduce conflict for GT in state 77 resolved as shift
WARNING: shift/reduce conflict for LT in state 77 resolved as shift
WARNING: shift/reduce conflict for ET in state 77 resolved as shift
WARNING: shift/reduce conflict for GTE in state 77 resolved as shift
WARNING: shift/reduce conflict for LTE in state 77 resolved as shift
WARNING: shift/reduce conflict for NE in state 77 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 78 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 78 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 78 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 78 resolved as shift
WARNING: shift/reduce conflict for GT in state 78 resolved as shift
WARNING: shift/reduce conflict for LT in state 78 resolved as shift
WARNING: shift/reduce conflict for ET in state 78 resolved as shift
WARNING: shift/reduce conflict for GTE in state 78 resolved as shift
WARNING: shift/reduce conflict for LTE in state 78 resolved as shift
WARNING: shift/reduce conflict for NE in state 78 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 79 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 79 resolved as shift
WARNING: shift/reduce conflict for GT in state 79 resolved as shift
WARNING: shift/reduce conflict for LT in state 79 resolved as shift
WARNING: shift/reduce conflict for ET in state 79 resolved as shift
WARNING: shift/reduce conflict for GTE in state 79 resolved as shift
WARNING: shift/reduce conflict for LTE in state 79 resolved as shift
WARNING: shift/reduce conflict for NE in state 79 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 80 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 80 resolved as shift
WARNING: shift/reduce conflict for GT in state 80 resolved as shift
WARNING: shift/reduce conflict for LT in state 80 resolved as shift
WARNING: shift/reduce conflict for ET in state 80 resolved as shift
WARNING: shift/reduce conflict for GTE in state 80 resolved as shift
WARNING: shift/reduce conflict for LTE in state 80 resolved as shift
WARNING: shift/reduce conflict for NE in state 80 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 81 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for GT in state 81 resolved as shift
WARNING: shift/reduce conflict for LT in state 81 resolved as shift
WARNING: shift/reduce conflict for ET in state 81 resolved as shift
WARNING: shift/reduce conflict for GTE in state 81 resolved as shift
WARNING: shift/reduce conflict for LTE in state 81 resolved as shift
WARNING: shift/reduce conflict for NE in state 81 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 82 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 82 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 82 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 82 resolved as shift
WARNING: shift/reduce conflict for GT in state 82 resolved as shift
WARNING: shift/reduce conflict for LT in state 82 resolved as shift
WARNING: shift/reduce conflict for ET in state 82 resolved as shift
WARNING: shift/reduce conflict for GTE in state 82 resolved as shift
WARNING: shift/reduce conflict for LTE in state 82 resolved as shift
WARNING: shift/reduce conflict for NE in state 82 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 83 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 83 resolved as shift
WARNING: shift/reduce conflict for GT in state 83 resolved as shift
WARNING: shift/reduce conflict for LT in state 83 resolved as shift
WARNING: shift/reduce conflict for ET in state 83 resolved as shift
WARNING: shift/reduce conflict for GTE in state 83 resolved as shift
WARNING: shift/reduce conflict for LTE in state 83 resolved as shift
WARNING: shift/reduce conflict for NE in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 84 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 84 resolved as shift
WARNING: shift/reduce conflict for GT in state 84 resolved as shift
WARNING: shift/reduce conflict for LT in state 84 resolved as shift
WARNING: shift/reduce conflict for ET in state 84 resolved as shift
WARNING: shift/reduce conflict for GTE in state 84 resolved as shift
WARNING: shift/reduce conflict for LTE in state 84 resolved as shift
WARNING: shift/reduce conflict for NE in state 84 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 85 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 85 resolved as shift
WARNING: shift/reduce conflict for GT in state 85 resolved as shift
WARNING: shift/reduce conflict for LT in state 85 resolved as shift
WARNING: shift/reduce conflict for ET in state 85 resolved as shift
WARNING: shift/reduce conflict for GTE in state 85 resolved as shift
WARNING: shift/reduce conflict for LTE in state 85 resolved as shift
WARNING: shift/reduce conflict for NE in state 85 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 86 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 86 resolved as shift
WARNING: shift/reduce conflict for GT in state 86 resolved as shift
WARNING: shift/reduce conflict for LT in state 86 resolved as shift
WARNING: shift/reduce conflict for ET in state 86 resolved as shift
WARNING: shift/reduce conflict for GTE in state 86 resolved as shift
WARNING: shift/reduce conflict for LTE in state 86 resolved as shift
WARNING: shift/reduce conflict for NE in state 86 resolved as shift
WARNING: shift/reduce conflict for CALL in state 87 resolved as shift
WARNING: shift/reduce conflict for DIGIT in state 87 resolved as shift
WARNING: shift/reduce conflict for ID in state 87 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 87 resolved as shift
WARNING: shift/reduce conflict for RANDOM in state 87 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 87 resolved as shift
WARNING: shift/reduce conflict for CONVERT in state 87 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 106 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for GT in state 106 resolved as shift
WARNING: shift/reduce conflict for LT in state 106 resolved as shift
WARNING: shift/reduce conflict for ET in state 106 resolved as shift
WARNING: shift/reduce conflict for GTE in state 106 resolved as shift
WARNING: shift/reduce conflict for LTE in state 106 resolved as shift
WARNING: shift/reduce conflict for NE in state 106 resolved as shift
