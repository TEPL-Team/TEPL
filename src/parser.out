Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> body
Rule 1     body -> stmt
Rule 2     body -> body stmt
Rule 3     stmt -> set_stmt
Rule 4     stmt -> output_stmt
Rule 5     stmt -> if_then_stmt
Rule 6     stmt -> input_stmt
Rule 7     stmt -> while_stmt
Rule 8     stmt -> repeat_stmt
Rule 9     stmt -> pause_stmt
Rule 10    var_stmt -> SET ID
Rule 11    set_stmt -> var_stmt TO expr
Rule 12    output_stmt -> OUTPUT expr
Rule 13    if_then_stmt -> IF expr THEN body END
Rule 14    input_stmt -> ASK expr
Rule 15    while_stmt -> WHILE condition DO body END
Rule 16    repeat -> REPEAT expr TIMES USING expr
Rule 17    repeat_stmt -> repeat body END
Rule 18    pause_stmt -> PAUSE expr
Rule 19    expr -> binop
Rule 20    expr -> condition
Rule 21    binop -> expr PLUS expr
Rule 22    binop -> expr MINUS expr
Rule 23    binop -> expr MULTIPLY expr
Rule 24    binop -> expr DIVIDE expr
Rule 25    condition -> expr GT expr
Rule 26    condition -> expr LT expr
Rule 27    condition -> expr ET expr
Rule 28    condition -> expr GTE expr
Rule 29    condition -> expr LTE expr
Rule 30    condition -> expr NE expr
Rule 31    expr -> DIGIT
Rule 32    expr -> ID
Rule 33    expr -> LPAREN expr RPAREN
Rule 34    expr -> RANDOM NUMBER FROM expr TO expr
Rule 35    expr -> TEXT
Rule 36    expr -> CONVERT expr TO datatype
Rule 37    datatype -> NUM
Rule 38    datatype -> TXT

Terminals, with rules where they appear

ASK                  : 14
COMMENT              : 
CONVERT              : 36
DIGIT                : 31
DIVIDE               : 24
DO                   : 15
END                  : 13 15 17
ET                   : 27
FROM                 : 34
GT                   : 25
GTE                  : 28
ID                   : 10 32
IF                   : 13
LPAREN               : 33
LT                   : 26
LTE                  : 29
MINUS                : 22
MULTIPLY             : 23
NE                   : 30
NUM                  : 37
NUMBER               : 34
OUTPUT               : 12
PAUSE                : 18
PLUS                 : 21
RANDOM               : 34
REPEAT               : 16
RPAREN               : 33
SET                  : 10
TEXT                 : 35
THEN                 : 13
TIMES                : 16
TO                   : 11 34 36
TXT                  : 38
USING                : 16
WHILE                : 15
error                : 

Nonterminals, with rules where they appear

binop                : 19
body                 : 2 13 15 17 0
condition            : 15 20
datatype             : 36
expr                 : 11 12 13 14 16 16 18 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 33 34 34 36
if_then_stmt         : 5
input_stmt           : 6
output_stmt          : 4
pause_stmt           : 9
repeat               : 17
repeat_stmt          : 8
set_stmt             : 3
stmt                 : 1 2
var_stmt             : 11
while_stmt           : 7

Parsing method: LALR

state 0

    (0) S' -> . body
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (11) set_stmt -> . var_stmt TO expr
    (12) output_stmt -> . OUTPUT expr
    (13) if_then_stmt -> . IF expr THEN body END
    (14) input_stmt -> . ASK expr
    (15) while_stmt -> . WHILE condition DO body END
    (17) repeat_stmt -> . repeat body END
    (18) pause_stmt -> . PAUSE expr
    (10) var_stmt -> . SET ID
    (16) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 11
    IF              shift and go to state 12
    ASK             shift and go to state 13
    WHILE           shift and go to state 14
    PAUSE           shift and go to state 16
    SET             shift and go to state 17
    REPEAT          shift and go to state 18

    body                           shift and go to state 1
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    var_stmt                       shift and go to state 10
    repeat                         shift and go to state 15

state 1

    (0) S' -> body .
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (11) set_stmt -> . var_stmt TO expr
    (12) output_stmt -> . OUTPUT expr
    (13) if_then_stmt -> . IF expr THEN body END
    (14) input_stmt -> . ASK expr
    (15) while_stmt -> . WHILE condition DO body END
    (17) repeat_stmt -> . repeat body END
    (18) pause_stmt -> . PAUSE expr
    (10) var_stmt -> . SET ID
    (16) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 11
    IF              shift and go to state 12
    ASK             shift and go to state 13
    WHILE           shift and go to state 14
    PAUSE           shift and go to state 16
    SET             shift and go to state 17
    REPEAT          shift and go to state 18

    stmt                           shift and go to state 19
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    var_stmt                       shift and go to state 10
    repeat                         shift and go to state 15

state 2

    (1) body -> stmt .

    OUTPUT          reduce using rule 1 (body -> stmt .)
    IF              reduce using rule 1 (body -> stmt .)
    ASK             reduce using rule 1 (body -> stmt .)
    WHILE           reduce using rule 1 (body -> stmt .)
    PAUSE           reduce using rule 1 (body -> stmt .)
    SET             reduce using rule 1 (body -> stmt .)
    REPEAT          reduce using rule 1 (body -> stmt .)
    $end            reduce using rule 1 (body -> stmt .)
    END             reduce using rule 1 (body -> stmt .)


state 3

    (3) stmt -> set_stmt .

    OUTPUT          reduce using rule 3 (stmt -> set_stmt .)
    IF              reduce using rule 3 (stmt -> set_stmt .)
    ASK             reduce using rule 3 (stmt -> set_stmt .)
    WHILE           reduce using rule 3 (stmt -> set_stmt .)
    PAUSE           reduce using rule 3 (stmt -> set_stmt .)
    SET             reduce using rule 3 (stmt -> set_stmt .)
    REPEAT          reduce using rule 3 (stmt -> set_stmt .)
    $end            reduce using rule 3 (stmt -> set_stmt .)
    END             reduce using rule 3 (stmt -> set_stmt .)


state 4

    (4) stmt -> output_stmt .

    OUTPUT          reduce using rule 4 (stmt -> output_stmt .)
    IF              reduce using rule 4 (stmt -> output_stmt .)
    ASK             reduce using rule 4 (stmt -> output_stmt .)
    WHILE           reduce using rule 4 (stmt -> output_stmt .)
    PAUSE           reduce using rule 4 (stmt -> output_stmt .)
    SET             reduce using rule 4 (stmt -> output_stmt .)
    REPEAT          reduce using rule 4 (stmt -> output_stmt .)
    $end            reduce using rule 4 (stmt -> output_stmt .)
    END             reduce using rule 4 (stmt -> output_stmt .)


state 5

    (5) stmt -> if_then_stmt .

    OUTPUT          reduce using rule 5 (stmt -> if_then_stmt .)
    IF              reduce using rule 5 (stmt -> if_then_stmt .)
    ASK             reduce using rule 5 (stmt -> if_then_stmt .)
    WHILE           reduce using rule 5 (stmt -> if_then_stmt .)
    PAUSE           reduce using rule 5 (stmt -> if_then_stmt .)
    SET             reduce using rule 5 (stmt -> if_then_stmt .)
    REPEAT          reduce using rule 5 (stmt -> if_then_stmt .)
    $end            reduce using rule 5 (stmt -> if_then_stmt .)
    END             reduce using rule 5 (stmt -> if_then_stmt .)


state 6

    (6) stmt -> input_stmt .

    OUTPUT          reduce using rule 6 (stmt -> input_stmt .)
    IF              reduce using rule 6 (stmt -> input_stmt .)
    ASK             reduce using rule 6 (stmt -> input_stmt .)
    WHILE           reduce using rule 6 (stmt -> input_stmt .)
    PAUSE           reduce using rule 6 (stmt -> input_stmt .)
    SET             reduce using rule 6 (stmt -> input_stmt .)
    REPEAT          reduce using rule 6 (stmt -> input_stmt .)
    $end            reduce using rule 6 (stmt -> input_stmt .)
    END             reduce using rule 6 (stmt -> input_stmt .)


state 7

    (7) stmt -> while_stmt .

    OUTPUT          reduce using rule 7 (stmt -> while_stmt .)
    IF              reduce using rule 7 (stmt -> while_stmt .)
    ASK             reduce using rule 7 (stmt -> while_stmt .)
    WHILE           reduce using rule 7 (stmt -> while_stmt .)
    PAUSE           reduce using rule 7 (stmt -> while_stmt .)
    SET             reduce using rule 7 (stmt -> while_stmt .)
    REPEAT          reduce using rule 7 (stmt -> while_stmt .)
    $end            reduce using rule 7 (stmt -> while_stmt .)
    END             reduce using rule 7 (stmt -> while_stmt .)


state 8

    (8) stmt -> repeat_stmt .

    OUTPUT          reduce using rule 8 (stmt -> repeat_stmt .)
    IF              reduce using rule 8 (stmt -> repeat_stmt .)
    ASK             reduce using rule 8 (stmt -> repeat_stmt .)
    WHILE           reduce using rule 8 (stmt -> repeat_stmt .)
    PAUSE           reduce using rule 8 (stmt -> repeat_stmt .)
    SET             reduce using rule 8 (stmt -> repeat_stmt .)
    REPEAT          reduce using rule 8 (stmt -> repeat_stmt .)
    $end            reduce using rule 8 (stmt -> repeat_stmt .)
    END             reduce using rule 8 (stmt -> repeat_stmt .)


state 9

    (9) stmt -> pause_stmt .

    OUTPUT          reduce using rule 9 (stmt -> pause_stmt .)
    IF              reduce using rule 9 (stmt -> pause_stmt .)
    ASK             reduce using rule 9 (stmt -> pause_stmt .)
    WHILE           reduce using rule 9 (stmt -> pause_stmt .)
    PAUSE           reduce using rule 9 (stmt -> pause_stmt .)
    SET             reduce using rule 9 (stmt -> pause_stmt .)
    REPEAT          reduce using rule 9 (stmt -> pause_stmt .)
    $end            reduce using rule 9 (stmt -> pause_stmt .)
    END             reduce using rule 9 (stmt -> pause_stmt .)


state 10

    (11) set_stmt -> var_stmt . TO expr

    TO              shift and go to state 20


state 11

    (12) output_stmt -> OUTPUT . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 21
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 12

    (13) if_then_stmt -> IF . expr THEN body END
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 30
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 13

    (14) input_stmt -> ASK . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 31
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 14

    (15) while_stmt -> WHILE . condition DO body END
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    condition                      shift and go to state 32
    expr                           shift and go to state 33
    binop                          shift and go to state 22

state 15

    (17) repeat_stmt -> repeat . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (11) set_stmt -> . var_stmt TO expr
    (12) output_stmt -> . OUTPUT expr
    (13) if_then_stmt -> . IF expr THEN body END
    (14) input_stmt -> . ASK expr
    (15) while_stmt -> . WHILE condition DO body END
    (17) repeat_stmt -> . repeat body END
    (18) pause_stmt -> . PAUSE expr
    (10) var_stmt -> . SET ID
    (16) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 11
    IF              shift and go to state 12
    ASK             shift and go to state 13
    WHILE           shift and go to state 14
    PAUSE           shift and go to state 16
    SET             shift and go to state 17
    REPEAT          shift and go to state 18

    repeat                         shift and go to state 15
    body                           shift and go to state 34
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    var_stmt                       shift and go to state 10

state 16

    (18) pause_stmt -> PAUSE . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 35
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 17

    (10) var_stmt -> SET . ID

    ID              shift and go to state 36


state 18

    (16) repeat -> REPEAT . expr TIMES USING expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 37
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 19

    (2) body -> body stmt .

    OUTPUT          reduce using rule 2 (body -> body stmt .)
    IF              reduce using rule 2 (body -> body stmt .)
    ASK             reduce using rule 2 (body -> body stmt .)
    WHILE           reduce using rule 2 (body -> body stmt .)
    PAUSE           reduce using rule 2 (body -> body stmt .)
    SET             reduce using rule 2 (body -> body stmt .)
    REPEAT          reduce using rule 2 (body -> body stmt .)
    $end            reduce using rule 2 (body -> body stmt .)
    END             reduce using rule 2 (body -> body stmt .)


state 20

    (11) set_stmt -> var_stmt TO . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 38
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 21

    (12) output_stmt -> OUTPUT expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

    OUTPUT          reduce using rule 12 (output_stmt -> OUTPUT expr .)
    IF              reduce using rule 12 (output_stmt -> OUTPUT expr .)
    ASK             reduce using rule 12 (output_stmt -> OUTPUT expr .)
    WHILE           reduce using rule 12 (output_stmt -> OUTPUT expr .)
    PAUSE           reduce using rule 12 (output_stmt -> OUTPUT expr .)
    SET             reduce using rule 12 (output_stmt -> OUTPUT expr .)
    REPEAT          reduce using rule 12 (output_stmt -> OUTPUT expr .)
    $end            reduce using rule 12 (output_stmt -> OUTPUT expr .)
    END             reduce using rule 12 (output_stmt -> OUTPUT expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48


state 22

    (19) expr -> binop .

    PLUS            reduce using rule 19 (expr -> binop .)
    MINUS           reduce using rule 19 (expr -> binop .)
    MULTIPLY        reduce using rule 19 (expr -> binop .)
    DIVIDE          reduce using rule 19 (expr -> binop .)
    GT              reduce using rule 19 (expr -> binop .)
    LT              reduce using rule 19 (expr -> binop .)
    ET              reduce using rule 19 (expr -> binop .)
    GTE             reduce using rule 19 (expr -> binop .)
    LTE             reduce using rule 19 (expr -> binop .)
    NE              reduce using rule 19 (expr -> binop .)
    OUTPUT          reduce using rule 19 (expr -> binop .)
    IF              reduce using rule 19 (expr -> binop .)
    ASK             reduce using rule 19 (expr -> binop .)
    WHILE           reduce using rule 19 (expr -> binop .)
    PAUSE           reduce using rule 19 (expr -> binop .)
    SET             reduce using rule 19 (expr -> binop .)
    REPEAT          reduce using rule 19 (expr -> binop .)
    $end            reduce using rule 19 (expr -> binop .)
    END             reduce using rule 19 (expr -> binop .)
    THEN            reduce using rule 19 (expr -> binop .)
    TIMES           reduce using rule 19 (expr -> binop .)
    RPAREN          reduce using rule 19 (expr -> binop .)
    TO              reduce using rule 19 (expr -> binop .)
    DO              reduce using rule 19 (expr -> binop .)


state 23

    (20) expr -> condition .

    PLUS            reduce using rule 20 (expr -> condition .)
    MINUS           reduce using rule 20 (expr -> condition .)
    MULTIPLY        reduce using rule 20 (expr -> condition .)
    DIVIDE          reduce using rule 20 (expr -> condition .)
    GT              reduce using rule 20 (expr -> condition .)
    LT              reduce using rule 20 (expr -> condition .)
    ET              reduce using rule 20 (expr -> condition .)
    GTE             reduce using rule 20 (expr -> condition .)
    LTE             reduce using rule 20 (expr -> condition .)
    NE              reduce using rule 20 (expr -> condition .)
    OUTPUT          reduce using rule 20 (expr -> condition .)
    IF              reduce using rule 20 (expr -> condition .)
    ASK             reduce using rule 20 (expr -> condition .)
    WHILE           reduce using rule 20 (expr -> condition .)
    PAUSE           reduce using rule 20 (expr -> condition .)
    SET             reduce using rule 20 (expr -> condition .)
    REPEAT          reduce using rule 20 (expr -> condition .)
    $end            reduce using rule 20 (expr -> condition .)
    END             reduce using rule 20 (expr -> condition .)
    THEN            reduce using rule 20 (expr -> condition .)
    TIMES           reduce using rule 20 (expr -> condition .)
    RPAREN          reduce using rule 20 (expr -> condition .)
    TO              reduce using rule 20 (expr -> condition .)
    DO              reduce using rule 20 (expr -> condition .)


state 24

    (31) expr -> DIGIT .

    PLUS            reduce using rule 31 (expr -> DIGIT .)
    MINUS           reduce using rule 31 (expr -> DIGIT .)
    MULTIPLY        reduce using rule 31 (expr -> DIGIT .)
    DIVIDE          reduce using rule 31 (expr -> DIGIT .)
    GT              reduce using rule 31 (expr -> DIGIT .)
    LT              reduce using rule 31 (expr -> DIGIT .)
    ET              reduce using rule 31 (expr -> DIGIT .)
    GTE             reduce using rule 31 (expr -> DIGIT .)
    LTE             reduce using rule 31 (expr -> DIGIT .)
    NE              reduce using rule 31 (expr -> DIGIT .)
    OUTPUT          reduce using rule 31 (expr -> DIGIT .)
    IF              reduce using rule 31 (expr -> DIGIT .)
    ASK             reduce using rule 31 (expr -> DIGIT .)
    WHILE           reduce using rule 31 (expr -> DIGIT .)
    PAUSE           reduce using rule 31 (expr -> DIGIT .)
    SET             reduce using rule 31 (expr -> DIGIT .)
    REPEAT          reduce using rule 31 (expr -> DIGIT .)
    $end            reduce using rule 31 (expr -> DIGIT .)
    END             reduce using rule 31 (expr -> DIGIT .)
    THEN            reduce using rule 31 (expr -> DIGIT .)
    TIMES           reduce using rule 31 (expr -> DIGIT .)
    RPAREN          reduce using rule 31 (expr -> DIGIT .)
    TO              reduce using rule 31 (expr -> DIGIT .)
    DO              reduce using rule 31 (expr -> DIGIT .)


state 25

    (32) expr -> ID .

    PLUS            reduce using rule 32 (expr -> ID .)
    MINUS           reduce using rule 32 (expr -> ID .)
    MULTIPLY        reduce using rule 32 (expr -> ID .)
    DIVIDE          reduce using rule 32 (expr -> ID .)
    GT              reduce using rule 32 (expr -> ID .)
    LT              reduce using rule 32 (expr -> ID .)
    ET              reduce using rule 32 (expr -> ID .)
    GTE             reduce using rule 32 (expr -> ID .)
    LTE             reduce using rule 32 (expr -> ID .)
    NE              reduce using rule 32 (expr -> ID .)
    OUTPUT          reduce using rule 32 (expr -> ID .)
    IF              reduce using rule 32 (expr -> ID .)
    ASK             reduce using rule 32 (expr -> ID .)
    WHILE           reduce using rule 32 (expr -> ID .)
    PAUSE           reduce using rule 32 (expr -> ID .)
    SET             reduce using rule 32 (expr -> ID .)
    REPEAT          reduce using rule 32 (expr -> ID .)
    $end            reduce using rule 32 (expr -> ID .)
    END             reduce using rule 32 (expr -> ID .)
    THEN            reduce using rule 32 (expr -> ID .)
    TIMES           reduce using rule 32 (expr -> ID .)
    RPAREN          reduce using rule 32 (expr -> ID .)
    TO              reduce using rule 32 (expr -> ID .)
    DO              reduce using rule 32 (expr -> ID .)


state 26

    (33) expr -> LPAREN . expr RPAREN
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 49
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 27

    (34) expr -> RANDOM . NUMBER FROM expr TO expr

    NUMBER          shift and go to state 50


state 28

    (35) expr -> TEXT .

    PLUS            reduce using rule 35 (expr -> TEXT .)
    MINUS           reduce using rule 35 (expr -> TEXT .)
    MULTIPLY        reduce using rule 35 (expr -> TEXT .)
    DIVIDE          reduce using rule 35 (expr -> TEXT .)
    GT              reduce using rule 35 (expr -> TEXT .)
    LT              reduce using rule 35 (expr -> TEXT .)
    ET              reduce using rule 35 (expr -> TEXT .)
    GTE             reduce using rule 35 (expr -> TEXT .)
    LTE             reduce using rule 35 (expr -> TEXT .)
    NE              reduce using rule 35 (expr -> TEXT .)
    OUTPUT          reduce using rule 35 (expr -> TEXT .)
    IF              reduce using rule 35 (expr -> TEXT .)
    ASK             reduce using rule 35 (expr -> TEXT .)
    WHILE           reduce using rule 35 (expr -> TEXT .)
    PAUSE           reduce using rule 35 (expr -> TEXT .)
    SET             reduce using rule 35 (expr -> TEXT .)
    REPEAT          reduce using rule 35 (expr -> TEXT .)
    $end            reduce using rule 35 (expr -> TEXT .)
    END             reduce using rule 35 (expr -> TEXT .)
    THEN            reduce using rule 35 (expr -> TEXT .)
    TIMES           reduce using rule 35 (expr -> TEXT .)
    RPAREN          reduce using rule 35 (expr -> TEXT .)
    TO              reduce using rule 35 (expr -> TEXT .)
    DO              reduce using rule 35 (expr -> TEXT .)


state 29

    (36) expr -> CONVERT . expr TO datatype
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 51
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 30

    (13) if_then_stmt -> IF expr . THEN body END
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

    THEN            shift and go to state 52
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48


state 31

    (14) input_stmt -> ASK expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

    OUTPUT          reduce using rule 14 (input_stmt -> ASK expr .)
    IF              reduce using rule 14 (input_stmt -> ASK expr .)
    ASK             reduce using rule 14 (input_stmt -> ASK expr .)
    WHILE           reduce using rule 14 (input_stmt -> ASK expr .)
    PAUSE           reduce using rule 14 (input_stmt -> ASK expr .)
    SET             reduce using rule 14 (input_stmt -> ASK expr .)
    REPEAT          reduce using rule 14 (input_stmt -> ASK expr .)
    $end            reduce using rule 14 (input_stmt -> ASK expr .)
    END             reduce using rule 14 (input_stmt -> ASK expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48


state 32

    (15) while_stmt -> WHILE condition . DO body END
    (20) expr -> condition .

    DO              shift and go to state 53
    GT              reduce using rule 20 (expr -> condition .)
    LT              reduce using rule 20 (expr -> condition .)
    ET              reduce using rule 20 (expr -> condition .)
    GTE             reduce using rule 20 (expr -> condition .)
    LTE             reduce using rule 20 (expr -> condition .)
    NE              reduce using rule 20 (expr -> condition .)
    PLUS            reduce using rule 20 (expr -> condition .)
    MINUS           reduce using rule 20 (expr -> condition .)
    MULTIPLY        reduce using rule 20 (expr -> condition .)
    DIVIDE          reduce using rule 20 (expr -> condition .)


state 33

    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr

    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42


state 34

    (17) repeat_stmt -> repeat body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (11) set_stmt -> . var_stmt TO expr
    (12) output_stmt -> . OUTPUT expr
    (13) if_then_stmt -> . IF expr THEN body END
    (14) input_stmt -> . ASK expr
    (15) while_stmt -> . WHILE condition DO body END
    (17) repeat_stmt -> . repeat body END
    (18) pause_stmt -> . PAUSE expr
    (10) var_stmt -> . SET ID
    (16) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 54
    OUTPUT          shift and go to state 11
    IF              shift and go to state 12
    ASK             shift and go to state 13
    WHILE           shift and go to state 14
    PAUSE           shift and go to state 16
    SET             shift and go to state 17
    REPEAT          shift and go to state 18

    repeat                         shift and go to state 15
    stmt                           shift and go to state 19
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    var_stmt                       shift and go to state 10

state 35

    (18) pause_stmt -> PAUSE expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

    OUTPUT          reduce using rule 18 (pause_stmt -> PAUSE expr .)
    IF              reduce using rule 18 (pause_stmt -> PAUSE expr .)
    ASK             reduce using rule 18 (pause_stmt -> PAUSE expr .)
    WHILE           reduce using rule 18 (pause_stmt -> PAUSE expr .)
    PAUSE           reduce using rule 18 (pause_stmt -> PAUSE expr .)
    SET             reduce using rule 18 (pause_stmt -> PAUSE expr .)
    REPEAT          reduce using rule 18 (pause_stmt -> PAUSE expr .)
    $end            reduce using rule 18 (pause_stmt -> PAUSE expr .)
    END             reduce using rule 18 (pause_stmt -> PAUSE expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48


state 36

    (10) var_stmt -> SET ID .

    TO              reduce using rule 10 (var_stmt -> SET ID .)


state 37

    (16) repeat -> REPEAT expr . TIMES USING expr
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

    TIMES           shift and go to state 55
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48


state 38

    (11) set_stmt -> var_stmt TO expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

    OUTPUT          reduce using rule 11 (set_stmt -> var_stmt TO expr .)
    IF              reduce using rule 11 (set_stmt -> var_stmt TO expr .)
    ASK             reduce using rule 11 (set_stmt -> var_stmt TO expr .)
    WHILE           reduce using rule 11 (set_stmt -> var_stmt TO expr .)
    PAUSE           reduce using rule 11 (set_stmt -> var_stmt TO expr .)
    SET             reduce using rule 11 (set_stmt -> var_stmt TO expr .)
    REPEAT          reduce using rule 11 (set_stmt -> var_stmt TO expr .)
    $end            reduce using rule 11 (set_stmt -> var_stmt TO expr .)
    END             reduce using rule 11 (set_stmt -> var_stmt TO expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48


state 39

    (21) binop -> expr PLUS . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 56
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 40

    (22) binop -> expr MINUS . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 57
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 41

    (23) binop -> expr MULTIPLY . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 58
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 42

    (24) binop -> expr DIVIDE . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 59
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 43

    (25) condition -> expr GT . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 60
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 44

    (26) condition -> expr LT . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 61
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 45

    (27) condition -> expr ET . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 62
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 46

    (28) condition -> expr GTE . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 63
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 47

    (29) condition -> expr LTE . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 64
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 48

    (30) condition -> expr NE . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 65
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 49

    (33) expr -> LPAREN expr . RPAREN
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

    RPAREN          shift and go to state 66
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48


state 50

    (34) expr -> RANDOM NUMBER . FROM expr TO expr

    FROM            shift and go to state 67


state 51

    (36) expr -> CONVERT expr . TO datatype
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

    TO              shift and go to state 68
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48


state 52

    (13) if_then_stmt -> IF expr THEN . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (11) set_stmt -> . var_stmt TO expr
    (12) output_stmt -> . OUTPUT expr
    (13) if_then_stmt -> . IF expr THEN body END
    (14) input_stmt -> . ASK expr
    (15) while_stmt -> . WHILE condition DO body END
    (17) repeat_stmt -> . repeat body END
    (18) pause_stmt -> . PAUSE expr
    (10) var_stmt -> . SET ID
    (16) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 11
    IF              shift and go to state 12
    ASK             shift and go to state 13
    WHILE           shift and go to state 14
    PAUSE           shift and go to state 16
    SET             shift and go to state 17
    REPEAT          shift and go to state 18

    body                           shift and go to state 69
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    var_stmt                       shift and go to state 10
    repeat                         shift and go to state 15

state 53

    (15) while_stmt -> WHILE condition DO . body END
    (1) body -> . stmt
    (2) body -> . body stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (11) set_stmt -> . var_stmt TO expr
    (12) output_stmt -> . OUTPUT expr
    (13) if_then_stmt -> . IF expr THEN body END
    (14) input_stmt -> . ASK expr
    (15) while_stmt -> . WHILE condition DO body END
    (17) repeat_stmt -> . repeat body END
    (18) pause_stmt -> . PAUSE expr
    (10) var_stmt -> . SET ID
    (16) repeat -> . REPEAT expr TIMES USING expr

    OUTPUT          shift and go to state 11
    IF              shift and go to state 12
    ASK             shift and go to state 13
    WHILE           shift and go to state 14
    PAUSE           shift and go to state 16
    SET             shift and go to state 17
    REPEAT          shift and go to state 18

    body                           shift and go to state 70
    stmt                           shift and go to state 2
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    var_stmt                       shift and go to state 10
    repeat                         shift and go to state 15

state 54

    (17) repeat_stmt -> repeat body END .

    OUTPUT          reduce using rule 17 (repeat_stmt -> repeat body END .)
    IF              reduce using rule 17 (repeat_stmt -> repeat body END .)
    ASK             reduce using rule 17 (repeat_stmt -> repeat body END .)
    WHILE           reduce using rule 17 (repeat_stmt -> repeat body END .)
    PAUSE           reduce using rule 17 (repeat_stmt -> repeat body END .)
    SET             reduce using rule 17 (repeat_stmt -> repeat body END .)
    REPEAT          reduce using rule 17 (repeat_stmt -> repeat body END .)
    $end            reduce using rule 17 (repeat_stmt -> repeat body END .)
    END             reduce using rule 17 (repeat_stmt -> repeat body END .)


state 55

    (16) repeat -> REPEAT expr TIMES . USING expr

    USING           shift and go to state 71


state 56

    (21) binop -> expr PLUS expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 21 (binop -> expr PLUS expr .)
    IF              reduce using rule 21 (binop -> expr PLUS expr .)
    ASK             reduce using rule 21 (binop -> expr PLUS expr .)
    WHILE           reduce using rule 21 (binop -> expr PLUS expr .)
    PAUSE           reduce using rule 21 (binop -> expr PLUS expr .)
    SET             reduce using rule 21 (binop -> expr PLUS expr .)
    REPEAT          reduce using rule 21 (binop -> expr PLUS expr .)
    $end            reduce using rule 21 (binop -> expr PLUS expr .)
    END             reduce using rule 21 (binop -> expr PLUS expr .)
    THEN            reduce using rule 21 (binop -> expr PLUS expr .)
    TIMES           reduce using rule 21 (binop -> expr PLUS expr .)
    RPAREN          reduce using rule 21 (binop -> expr PLUS expr .)
    TO              reduce using rule 21 (binop -> expr PLUS expr .)
    DO              reduce using rule 21 (binop -> expr PLUS expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 21 (binop -> expr PLUS expr .) ]
  ! MINUS           [ reduce using rule 21 (binop -> expr PLUS expr .) ]
  ! MULTIPLY        [ reduce using rule 21 (binop -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 21 (binop -> expr PLUS expr .) ]
  ! GT              [ reduce using rule 21 (binop -> expr PLUS expr .) ]
  ! LT              [ reduce using rule 21 (binop -> expr PLUS expr .) ]
  ! ET              [ reduce using rule 21 (binop -> expr PLUS expr .) ]
  ! GTE             [ reduce using rule 21 (binop -> expr PLUS expr .) ]
  ! LTE             [ reduce using rule 21 (binop -> expr PLUS expr .) ]
  ! NE              [ reduce using rule 21 (binop -> expr PLUS expr .) ]


state 57

    (22) binop -> expr MINUS expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 22 (binop -> expr MINUS expr .)
    IF              reduce using rule 22 (binop -> expr MINUS expr .)
    ASK             reduce using rule 22 (binop -> expr MINUS expr .)
    WHILE           reduce using rule 22 (binop -> expr MINUS expr .)
    PAUSE           reduce using rule 22 (binop -> expr MINUS expr .)
    SET             reduce using rule 22 (binop -> expr MINUS expr .)
    REPEAT          reduce using rule 22 (binop -> expr MINUS expr .)
    $end            reduce using rule 22 (binop -> expr MINUS expr .)
    END             reduce using rule 22 (binop -> expr MINUS expr .)
    THEN            reduce using rule 22 (binop -> expr MINUS expr .)
    TIMES           reduce using rule 22 (binop -> expr MINUS expr .)
    RPAREN          reduce using rule 22 (binop -> expr MINUS expr .)
    TO              reduce using rule 22 (binop -> expr MINUS expr .)
    DO              reduce using rule 22 (binop -> expr MINUS expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 22 (binop -> expr MINUS expr .) ]
  ! MINUS           [ reduce using rule 22 (binop -> expr MINUS expr .) ]
  ! MULTIPLY        [ reduce using rule 22 (binop -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 22 (binop -> expr MINUS expr .) ]
  ! GT              [ reduce using rule 22 (binop -> expr MINUS expr .) ]
  ! LT              [ reduce using rule 22 (binop -> expr MINUS expr .) ]
  ! ET              [ reduce using rule 22 (binop -> expr MINUS expr .) ]
  ! GTE             [ reduce using rule 22 (binop -> expr MINUS expr .) ]
  ! LTE             [ reduce using rule 22 (binop -> expr MINUS expr .) ]
  ! NE              [ reduce using rule 22 (binop -> expr MINUS expr .) ]


state 58

    (23) binop -> expr MULTIPLY expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 23 (binop -> expr MULTIPLY expr .)
    IF              reduce using rule 23 (binop -> expr MULTIPLY expr .)
    ASK             reduce using rule 23 (binop -> expr MULTIPLY expr .)
    WHILE           reduce using rule 23 (binop -> expr MULTIPLY expr .)
    PAUSE           reduce using rule 23 (binop -> expr MULTIPLY expr .)
    SET             reduce using rule 23 (binop -> expr MULTIPLY expr .)
    REPEAT          reduce using rule 23 (binop -> expr MULTIPLY expr .)
    $end            reduce using rule 23 (binop -> expr MULTIPLY expr .)
    END             reduce using rule 23 (binop -> expr MULTIPLY expr .)
    THEN            reduce using rule 23 (binop -> expr MULTIPLY expr .)
    TIMES           reduce using rule 23 (binop -> expr MULTIPLY expr .)
    RPAREN          reduce using rule 23 (binop -> expr MULTIPLY expr .)
    TO              reduce using rule 23 (binop -> expr MULTIPLY expr .)
    DO              reduce using rule 23 (binop -> expr MULTIPLY expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 23 (binop -> expr MULTIPLY expr .) ]
  ! MINUS           [ reduce using rule 23 (binop -> expr MULTIPLY expr .) ]
  ! MULTIPLY        [ reduce using rule 23 (binop -> expr MULTIPLY expr .) ]
  ! DIVIDE          [ reduce using rule 23 (binop -> expr MULTIPLY expr .) ]
  ! GT              [ reduce using rule 23 (binop -> expr MULTIPLY expr .) ]
  ! LT              [ reduce using rule 23 (binop -> expr MULTIPLY expr .) ]
  ! ET              [ reduce using rule 23 (binop -> expr MULTIPLY expr .) ]
  ! GTE             [ reduce using rule 23 (binop -> expr MULTIPLY expr .) ]
  ! LTE             [ reduce using rule 23 (binop -> expr MULTIPLY expr .) ]
  ! NE              [ reduce using rule 23 (binop -> expr MULTIPLY expr .) ]


state 59

    (24) binop -> expr DIVIDE expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 24 (binop -> expr DIVIDE expr .)
    IF              reduce using rule 24 (binop -> expr DIVIDE expr .)
    ASK             reduce using rule 24 (binop -> expr DIVIDE expr .)
    WHILE           reduce using rule 24 (binop -> expr DIVIDE expr .)
    PAUSE           reduce using rule 24 (binop -> expr DIVIDE expr .)
    SET             reduce using rule 24 (binop -> expr DIVIDE expr .)
    REPEAT          reduce using rule 24 (binop -> expr DIVIDE expr .)
    $end            reduce using rule 24 (binop -> expr DIVIDE expr .)
    END             reduce using rule 24 (binop -> expr DIVIDE expr .)
    THEN            reduce using rule 24 (binop -> expr DIVIDE expr .)
    TIMES           reduce using rule 24 (binop -> expr DIVIDE expr .)
    RPAREN          reduce using rule 24 (binop -> expr DIVIDE expr .)
    TO              reduce using rule 24 (binop -> expr DIVIDE expr .)
    DO              reduce using rule 24 (binop -> expr DIVIDE expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 24 (binop -> expr DIVIDE expr .) ]
  ! MINUS           [ reduce using rule 24 (binop -> expr DIVIDE expr .) ]
  ! MULTIPLY        [ reduce using rule 24 (binop -> expr DIVIDE expr .) ]
  ! DIVIDE          [ reduce using rule 24 (binop -> expr DIVIDE expr .) ]
  ! GT              [ reduce using rule 24 (binop -> expr DIVIDE expr .) ]
  ! LT              [ reduce using rule 24 (binop -> expr DIVIDE expr .) ]
  ! ET              [ reduce using rule 24 (binop -> expr DIVIDE expr .) ]
  ! GTE             [ reduce using rule 24 (binop -> expr DIVIDE expr .) ]
  ! LTE             [ reduce using rule 24 (binop -> expr DIVIDE expr .) ]
  ! NE              [ reduce using rule 24 (binop -> expr DIVIDE expr .) ]


state 60

    (25) condition -> expr GT expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 25 (condition -> expr GT expr .)
    IF              reduce using rule 25 (condition -> expr GT expr .)
    ASK             reduce using rule 25 (condition -> expr GT expr .)
    WHILE           reduce using rule 25 (condition -> expr GT expr .)
    PAUSE           reduce using rule 25 (condition -> expr GT expr .)
    SET             reduce using rule 25 (condition -> expr GT expr .)
    REPEAT          reduce using rule 25 (condition -> expr GT expr .)
    $end            reduce using rule 25 (condition -> expr GT expr .)
    END             reduce using rule 25 (condition -> expr GT expr .)
    THEN            reduce using rule 25 (condition -> expr GT expr .)
    DO              reduce using rule 25 (condition -> expr GT expr .)
    TIMES           reduce using rule 25 (condition -> expr GT expr .)
    RPAREN          reduce using rule 25 (condition -> expr GT expr .)
    TO              reduce using rule 25 (condition -> expr GT expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 25 (condition -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 25 (condition -> expr GT expr .) ]
  ! MULTIPLY        [ reduce using rule 25 (condition -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 25 (condition -> expr GT expr .) ]
  ! GT              [ reduce using rule 25 (condition -> expr GT expr .) ]
  ! LT              [ reduce using rule 25 (condition -> expr GT expr .) ]
  ! ET              [ reduce using rule 25 (condition -> expr GT expr .) ]
  ! GTE             [ reduce using rule 25 (condition -> expr GT expr .) ]
  ! LTE             [ reduce using rule 25 (condition -> expr GT expr .) ]
  ! NE              [ reduce using rule 25 (condition -> expr GT expr .) ]


state 61

    (26) condition -> expr LT expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 26 (condition -> expr LT expr .)
    IF              reduce using rule 26 (condition -> expr LT expr .)
    ASK             reduce using rule 26 (condition -> expr LT expr .)
    WHILE           reduce using rule 26 (condition -> expr LT expr .)
    PAUSE           reduce using rule 26 (condition -> expr LT expr .)
    SET             reduce using rule 26 (condition -> expr LT expr .)
    REPEAT          reduce using rule 26 (condition -> expr LT expr .)
    $end            reduce using rule 26 (condition -> expr LT expr .)
    END             reduce using rule 26 (condition -> expr LT expr .)
    THEN            reduce using rule 26 (condition -> expr LT expr .)
    DO              reduce using rule 26 (condition -> expr LT expr .)
    TIMES           reduce using rule 26 (condition -> expr LT expr .)
    RPAREN          reduce using rule 26 (condition -> expr LT expr .)
    TO              reduce using rule 26 (condition -> expr LT expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 26 (condition -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 26 (condition -> expr LT expr .) ]
  ! MULTIPLY        [ reduce using rule 26 (condition -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 26 (condition -> expr LT expr .) ]
  ! GT              [ reduce using rule 26 (condition -> expr LT expr .) ]
  ! LT              [ reduce using rule 26 (condition -> expr LT expr .) ]
  ! ET              [ reduce using rule 26 (condition -> expr LT expr .) ]
  ! GTE             [ reduce using rule 26 (condition -> expr LT expr .) ]
  ! LTE             [ reduce using rule 26 (condition -> expr LT expr .) ]
  ! NE              [ reduce using rule 26 (condition -> expr LT expr .) ]


state 62

    (27) condition -> expr ET expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 27 (condition -> expr ET expr .)
    IF              reduce using rule 27 (condition -> expr ET expr .)
    ASK             reduce using rule 27 (condition -> expr ET expr .)
    WHILE           reduce using rule 27 (condition -> expr ET expr .)
    PAUSE           reduce using rule 27 (condition -> expr ET expr .)
    SET             reduce using rule 27 (condition -> expr ET expr .)
    REPEAT          reduce using rule 27 (condition -> expr ET expr .)
    $end            reduce using rule 27 (condition -> expr ET expr .)
    END             reduce using rule 27 (condition -> expr ET expr .)
    THEN            reduce using rule 27 (condition -> expr ET expr .)
    DO              reduce using rule 27 (condition -> expr ET expr .)
    TIMES           reduce using rule 27 (condition -> expr ET expr .)
    RPAREN          reduce using rule 27 (condition -> expr ET expr .)
    TO              reduce using rule 27 (condition -> expr ET expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 27 (condition -> expr ET expr .) ]
  ! MINUS           [ reduce using rule 27 (condition -> expr ET expr .) ]
  ! MULTIPLY        [ reduce using rule 27 (condition -> expr ET expr .) ]
  ! DIVIDE          [ reduce using rule 27 (condition -> expr ET expr .) ]
  ! GT              [ reduce using rule 27 (condition -> expr ET expr .) ]
  ! LT              [ reduce using rule 27 (condition -> expr ET expr .) ]
  ! ET              [ reduce using rule 27 (condition -> expr ET expr .) ]
  ! GTE             [ reduce using rule 27 (condition -> expr ET expr .) ]
  ! LTE             [ reduce using rule 27 (condition -> expr ET expr .) ]
  ! NE              [ reduce using rule 27 (condition -> expr ET expr .) ]


state 63

    (28) condition -> expr GTE expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 28 (condition -> expr GTE expr .)
    IF              reduce using rule 28 (condition -> expr GTE expr .)
    ASK             reduce using rule 28 (condition -> expr GTE expr .)
    WHILE           reduce using rule 28 (condition -> expr GTE expr .)
    PAUSE           reduce using rule 28 (condition -> expr GTE expr .)
    SET             reduce using rule 28 (condition -> expr GTE expr .)
    REPEAT          reduce using rule 28 (condition -> expr GTE expr .)
    $end            reduce using rule 28 (condition -> expr GTE expr .)
    END             reduce using rule 28 (condition -> expr GTE expr .)
    THEN            reduce using rule 28 (condition -> expr GTE expr .)
    DO              reduce using rule 28 (condition -> expr GTE expr .)
    TIMES           reduce using rule 28 (condition -> expr GTE expr .)
    RPAREN          reduce using rule 28 (condition -> expr GTE expr .)
    TO              reduce using rule 28 (condition -> expr GTE expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 28 (condition -> expr GTE expr .) ]
  ! MINUS           [ reduce using rule 28 (condition -> expr GTE expr .) ]
  ! MULTIPLY        [ reduce using rule 28 (condition -> expr GTE expr .) ]
  ! DIVIDE          [ reduce using rule 28 (condition -> expr GTE expr .) ]
  ! GT              [ reduce using rule 28 (condition -> expr GTE expr .) ]
  ! LT              [ reduce using rule 28 (condition -> expr GTE expr .) ]
  ! ET              [ reduce using rule 28 (condition -> expr GTE expr .) ]
  ! GTE             [ reduce using rule 28 (condition -> expr GTE expr .) ]
  ! LTE             [ reduce using rule 28 (condition -> expr GTE expr .) ]
  ! NE              [ reduce using rule 28 (condition -> expr GTE expr .) ]


state 64

    (29) condition -> expr LTE expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 29 (condition -> expr LTE expr .)
    IF              reduce using rule 29 (condition -> expr LTE expr .)
    ASK             reduce using rule 29 (condition -> expr LTE expr .)
    WHILE           reduce using rule 29 (condition -> expr LTE expr .)
    PAUSE           reduce using rule 29 (condition -> expr LTE expr .)
    SET             reduce using rule 29 (condition -> expr LTE expr .)
    REPEAT          reduce using rule 29 (condition -> expr LTE expr .)
    $end            reduce using rule 29 (condition -> expr LTE expr .)
    END             reduce using rule 29 (condition -> expr LTE expr .)
    THEN            reduce using rule 29 (condition -> expr LTE expr .)
    DO              reduce using rule 29 (condition -> expr LTE expr .)
    TIMES           reduce using rule 29 (condition -> expr LTE expr .)
    RPAREN          reduce using rule 29 (condition -> expr LTE expr .)
    TO              reduce using rule 29 (condition -> expr LTE expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 29 (condition -> expr LTE expr .) ]
  ! MINUS           [ reduce using rule 29 (condition -> expr LTE expr .) ]
  ! MULTIPLY        [ reduce using rule 29 (condition -> expr LTE expr .) ]
  ! DIVIDE          [ reduce using rule 29 (condition -> expr LTE expr .) ]
  ! GT              [ reduce using rule 29 (condition -> expr LTE expr .) ]
  ! LT              [ reduce using rule 29 (condition -> expr LTE expr .) ]
  ! ET              [ reduce using rule 29 (condition -> expr LTE expr .) ]
  ! GTE             [ reduce using rule 29 (condition -> expr LTE expr .) ]
  ! LTE             [ reduce using rule 29 (condition -> expr LTE expr .) ]
  ! NE              [ reduce using rule 29 (condition -> expr LTE expr .) ]


state 65

    (30) condition -> expr NE expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 30 (condition -> expr NE expr .)
    IF              reduce using rule 30 (condition -> expr NE expr .)
    ASK             reduce using rule 30 (condition -> expr NE expr .)
    WHILE           reduce using rule 30 (condition -> expr NE expr .)
    PAUSE           reduce using rule 30 (condition -> expr NE expr .)
    SET             reduce using rule 30 (condition -> expr NE expr .)
    REPEAT          reduce using rule 30 (condition -> expr NE expr .)
    $end            reduce using rule 30 (condition -> expr NE expr .)
    END             reduce using rule 30 (condition -> expr NE expr .)
    THEN            reduce using rule 30 (condition -> expr NE expr .)
    DO              reduce using rule 30 (condition -> expr NE expr .)
    TIMES           reduce using rule 30 (condition -> expr NE expr .)
    RPAREN          reduce using rule 30 (condition -> expr NE expr .)
    TO              reduce using rule 30 (condition -> expr NE expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 30 (condition -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 30 (condition -> expr NE expr .) ]
  ! MULTIPLY        [ reduce using rule 30 (condition -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 30 (condition -> expr NE expr .) ]
  ! GT              [ reduce using rule 30 (condition -> expr NE expr .) ]
  ! LT              [ reduce using rule 30 (condition -> expr NE expr .) ]
  ! ET              [ reduce using rule 30 (condition -> expr NE expr .) ]
  ! GTE             [ reduce using rule 30 (condition -> expr NE expr .) ]
  ! LTE             [ reduce using rule 30 (condition -> expr NE expr .) ]
  ! NE              [ reduce using rule 30 (condition -> expr NE expr .) ]


state 66

    (33) expr -> LPAREN expr RPAREN .

    PLUS            reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    MULTIPLY        reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    ET              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    GTE             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    LTE             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    OUTPUT          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    IF              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    ASK             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    WHILE           reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    PAUSE           reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    SET             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    REPEAT          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    END             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    THEN            reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    TO              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    DO              reduce using rule 33 (expr -> LPAREN expr RPAREN .)


state 67

    (34) expr -> RANDOM NUMBER FROM . expr TO expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 72
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 68

    (36) expr -> CONVERT expr TO . datatype
    (37) datatype -> . NUM
    (38) datatype -> . TXT

    NUM             shift and go to state 74
    TXT             shift and go to state 75

    datatype                       shift and go to state 73

state 69

    (13) if_then_stmt -> IF expr THEN body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (11) set_stmt -> . var_stmt TO expr
    (12) output_stmt -> . OUTPUT expr
    (13) if_then_stmt -> . IF expr THEN body END
    (14) input_stmt -> . ASK expr
    (15) while_stmt -> . WHILE condition DO body END
    (17) repeat_stmt -> . repeat body END
    (18) pause_stmt -> . PAUSE expr
    (10) var_stmt -> . SET ID
    (16) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 76
    OUTPUT          shift and go to state 11
    IF              shift and go to state 12
    ASK             shift and go to state 13
    WHILE           shift and go to state 14
    PAUSE           shift and go to state 16
    SET             shift and go to state 17
    REPEAT          shift and go to state 18

    stmt                           shift and go to state 19
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    var_stmt                       shift and go to state 10
    repeat                         shift and go to state 15

state 70

    (15) while_stmt -> WHILE condition DO body . END
    (2) body -> body . stmt
    (3) stmt -> . set_stmt
    (4) stmt -> . output_stmt
    (5) stmt -> . if_then_stmt
    (6) stmt -> . input_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . repeat_stmt
    (9) stmt -> . pause_stmt
    (11) set_stmt -> . var_stmt TO expr
    (12) output_stmt -> . OUTPUT expr
    (13) if_then_stmt -> . IF expr THEN body END
    (14) input_stmt -> . ASK expr
    (15) while_stmt -> . WHILE condition DO body END
    (17) repeat_stmt -> . repeat body END
    (18) pause_stmt -> . PAUSE expr
    (10) var_stmt -> . SET ID
    (16) repeat -> . REPEAT expr TIMES USING expr

    END             shift and go to state 77
    OUTPUT          shift and go to state 11
    IF              shift and go to state 12
    ASK             shift and go to state 13
    WHILE           shift and go to state 14
    PAUSE           shift and go to state 16
    SET             shift and go to state 17
    REPEAT          shift and go to state 18

    stmt                           shift and go to state 19
    set_stmt                       shift and go to state 3
    output_stmt                    shift and go to state 4
    if_then_stmt                   shift and go to state 5
    input_stmt                     shift and go to state 6
    while_stmt                     shift and go to state 7
    repeat_stmt                    shift and go to state 8
    pause_stmt                     shift and go to state 9
    var_stmt                       shift and go to state 10
    repeat                         shift and go to state 15

state 71

    (16) repeat -> REPEAT expr TIMES USING . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 78
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 72

    (34) expr -> RANDOM NUMBER FROM expr . TO expr
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

    TO              shift and go to state 79
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48


state 73

    (36) expr -> CONVERT expr TO datatype .

    PLUS            reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    MINUS           reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    MULTIPLY        reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    DIVIDE          reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    GT              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    LT              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    ET              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    GTE             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    LTE             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    NE              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    OUTPUT          reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    IF              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    ASK             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    WHILE           reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    PAUSE           reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    SET             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    REPEAT          reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    $end            reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    END             reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    THEN            reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    TIMES           reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    RPAREN          reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    TO              reduce using rule 36 (expr -> CONVERT expr TO datatype .)
    DO              reduce using rule 36 (expr -> CONVERT expr TO datatype .)


state 74

    (37) datatype -> NUM .

    PLUS            reduce using rule 37 (datatype -> NUM .)
    MINUS           reduce using rule 37 (datatype -> NUM .)
    MULTIPLY        reduce using rule 37 (datatype -> NUM .)
    DIVIDE          reduce using rule 37 (datatype -> NUM .)
    GT              reduce using rule 37 (datatype -> NUM .)
    LT              reduce using rule 37 (datatype -> NUM .)
    ET              reduce using rule 37 (datatype -> NUM .)
    GTE             reduce using rule 37 (datatype -> NUM .)
    LTE             reduce using rule 37 (datatype -> NUM .)
    NE              reduce using rule 37 (datatype -> NUM .)
    OUTPUT          reduce using rule 37 (datatype -> NUM .)
    IF              reduce using rule 37 (datatype -> NUM .)
    ASK             reduce using rule 37 (datatype -> NUM .)
    WHILE           reduce using rule 37 (datatype -> NUM .)
    PAUSE           reduce using rule 37 (datatype -> NUM .)
    SET             reduce using rule 37 (datatype -> NUM .)
    REPEAT          reduce using rule 37 (datatype -> NUM .)
    $end            reduce using rule 37 (datatype -> NUM .)
    END             reduce using rule 37 (datatype -> NUM .)
    THEN            reduce using rule 37 (datatype -> NUM .)
    TIMES           reduce using rule 37 (datatype -> NUM .)
    RPAREN          reduce using rule 37 (datatype -> NUM .)
    TO              reduce using rule 37 (datatype -> NUM .)
    DO              reduce using rule 37 (datatype -> NUM .)


state 75

    (38) datatype -> TXT .

    PLUS            reduce using rule 38 (datatype -> TXT .)
    MINUS           reduce using rule 38 (datatype -> TXT .)
    MULTIPLY        reduce using rule 38 (datatype -> TXT .)
    DIVIDE          reduce using rule 38 (datatype -> TXT .)
    GT              reduce using rule 38 (datatype -> TXT .)
    LT              reduce using rule 38 (datatype -> TXT .)
    ET              reduce using rule 38 (datatype -> TXT .)
    GTE             reduce using rule 38 (datatype -> TXT .)
    LTE             reduce using rule 38 (datatype -> TXT .)
    NE              reduce using rule 38 (datatype -> TXT .)
    OUTPUT          reduce using rule 38 (datatype -> TXT .)
    IF              reduce using rule 38 (datatype -> TXT .)
    ASK             reduce using rule 38 (datatype -> TXT .)
    WHILE           reduce using rule 38 (datatype -> TXT .)
    PAUSE           reduce using rule 38 (datatype -> TXT .)
    SET             reduce using rule 38 (datatype -> TXT .)
    REPEAT          reduce using rule 38 (datatype -> TXT .)
    $end            reduce using rule 38 (datatype -> TXT .)
    END             reduce using rule 38 (datatype -> TXT .)
    THEN            reduce using rule 38 (datatype -> TXT .)
    TIMES           reduce using rule 38 (datatype -> TXT .)
    RPAREN          reduce using rule 38 (datatype -> TXT .)
    TO              reduce using rule 38 (datatype -> TXT .)
    DO              reduce using rule 38 (datatype -> TXT .)


state 76

    (13) if_then_stmt -> IF expr THEN body END .

    OUTPUT          reduce using rule 13 (if_then_stmt -> IF expr THEN body END .)
    IF              reduce using rule 13 (if_then_stmt -> IF expr THEN body END .)
    ASK             reduce using rule 13 (if_then_stmt -> IF expr THEN body END .)
    WHILE           reduce using rule 13 (if_then_stmt -> IF expr THEN body END .)
    PAUSE           reduce using rule 13 (if_then_stmt -> IF expr THEN body END .)
    SET             reduce using rule 13 (if_then_stmt -> IF expr THEN body END .)
    REPEAT          reduce using rule 13 (if_then_stmt -> IF expr THEN body END .)
    $end            reduce using rule 13 (if_then_stmt -> IF expr THEN body END .)
    END             reduce using rule 13 (if_then_stmt -> IF expr THEN body END .)


state 77

    (15) while_stmt -> WHILE condition DO body END .

    OUTPUT          reduce using rule 15 (while_stmt -> WHILE condition DO body END .)
    IF              reduce using rule 15 (while_stmt -> WHILE condition DO body END .)
    ASK             reduce using rule 15 (while_stmt -> WHILE condition DO body END .)
    WHILE           reduce using rule 15 (while_stmt -> WHILE condition DO body END .)
    PAUSE           reduce using rule 15 (while_stmt -> WHILE condition DO body END .)
    SET             reduce using rule 15 (while_stmt -> WHILE condition DO body END .)
    REPEAT          reduce using rule 15 (while_stmt -> WHILE condition DO body END .)
    $end            reduce using rule 15 (while_stmt -> WHILE condition DO body END .)
    END             reduce using rule 15 (while_stmt -> WHILE condition DO body END .)


state 78

    (16) repeat -> REPEAT expr TIMES USING expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

    OUTPUT          reduce using rule 16 (repeat -> REPEAT expr TIMES USING expr .)
    IF              reduce using rule 16 (repeat -> REPEAT expr TIMES USING expr .)
    ASK             reduce using rule 16 (repeat -> REPEAT expr TIMES USING expr .)
    WHILE           reduce using rule 16 (repeat -> REPEAT expr TIMES USING expr .)
    PAUSE           reduce using rule 16 (repeat -> REPEAT expr TIMES USING expr .)
    SET             reduce using rule 16 (repeat -> REPEAT expr TIMES USING expr .)
    REPEAT          reduce using rule 16 (repeat -> REPEAT expr TIMES USING expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48


state 79

    (34) expr -> RANDOM NUMBER FROM expr TO . expr
    (19) expr -> . binop
    (20) expr -> . condition
    (31) expr -> . DIGIT
    (32) expr -> . ID
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . RANDOM NUMBER FROM expr TO expr
    (35) expr -> . TEXT
    (36) expr -> . CONVERT expr TO datatype
    (21) binop -> . expr PLUS expr
    (22) binop -> . expr MINUS expr
    (23) binop -> . expr MULTIPLY expr
    (24) binop -> . expr DIVIDE expr
    (25) condition -> . expr GT expr
    (26) condition -> . expr LT expr
    (27) condition -> . expr ET expr
    (28) condition -> . expr GTE expr
    (29) condition -> . expr LTE expr
    (30) condition -> . expr NE expr

    DIGIT           shift and go to state 24
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    RANDOM          shift and go to state 27
    TEXT            shift and go to state 28
    CONVERT         shift and go to state 29

    expr                           shift and go to state 80
    binop                          shift and go to state 22
    condition                      shift and go to state 23

state 80

    (34) expr -> RANDOM NUMBER FROM expr TO expr .
    (21) binop -> expr . PLUS expr
    (22) binop -> expr . MINUS expr
    (23) binop -> expr . MULTIPLY expr
    (24) binop -> expr . DIVIDE expr
    (25) condition -> expr . GT expr
    (26) condition -> expr . LT expr
    (27) condition -> expr . ET expr
    (28) condition -> expr . GTE expr
    (29) condition -> expr . LTE expr
    (30) condition -> expr . NE expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for ET resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    OUTPUT          reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    IF              reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    ASK             reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    WHILE           reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    PAUSE           reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    SET             reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    REPEAT          reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    $end            reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    END             reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    THEN            reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    TIMES           reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    RPAREN          reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    TO              reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    DO              reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    MULTIPLY        shift and go to state 41
    DIVIDE          shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    ET              shift and go to state 45
    GTE             shift and go to state 46
    LTE             shift and go to state 47
    NE              shift and go to state 48

  ! PLUS            [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! MINUS           [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! MULTIPLY        [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! DIVIDE          [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! GT              [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! LT              [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! ET              [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! GTE             [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! LTE             [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]
  ! NE              [ reduce using rule 34 (expr -> RANDOM NUMBER FROM expr TO expr .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 56 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 56 resolved as shift
WARNING: shift/reduce conflict for GT in state 56 resolved as shift
WARNING: shift/reduce conflict for LT in state 56 resolved as shift
WARNING: shift/reduce conflict for ET in state 56 resolved as shift
WARNING: shift/reduce conflict for GTE in state 56 resolved as shift
WARNING: shift/reduce conflict for LTE in state 56 resolved as shift
WARNING: shift/reduce conflict for NE in state 56 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 57 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 57 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 57 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 57 resolved as shift
WARNING: shift/reduce conflict for GT in state 57 resolved as shift
WARNING: shift/reduce conflict for LT in state 57 resolved as shift
WARNING: shift/reduce conflict for ET in state 57 resolved as shift
WARNING: shift/reduce conflict for GTE in state 57 resolved as shift
WARNING: shift/reduce conflict for LTE in state 57 resolved as shift
WARNING: shift/reduce conflict for NE in state 57 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 58 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 58 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 58 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 58 resolved as shift
WARNING: shift/reduce conflict for GT in state 58 resolved as shift
WARNING: shift/reduce conflict for LT in state 58 resolved as shift
WARNING: shift/reduce conflict for ET in state 58 resolved as shift
WARNING: shift/reduce conflict for GTE in state 58 resolved as shift
WARNING: shift/reduce conflict for LTE in state 58 resolved as shift
WARNING: shift/reduce conflict for NE in state 58 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 59 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 59 resolved as shift
WARNING: shift/reduce conflict for GT in state 59 resolved as shift
WARNING: shift/reduce conflict for LT in state 59 resolved as shift
WARNING: shift/reduce conflict for ET in state 59 resolved as shift
WARNING: shift/reduce conflict for GTE in state 59 resolved as shift
WARNING: shift/reduce conflict for LTE in state 59 resolved as shift
WARNING: shift/reduce conflict for NE in state 59 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 60 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 60 resolved as shift
WARNING: shift/reduce conflict for GT in state 60 resolved as shift
WARNING: shift/reduce conflict for LT in state 60 resolved as shift
WARNING: shift/reduce conflict for ET in state 60 resolved as shift
WARNING: shift/reduce conflict for GTE in state 60 resolved as shift
WARNING: shift/reduce conflict for LTE in state 60 resolved as shift
WARNING: shift/reduce conflict for NE in state 60 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 61 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 61 resolved as shift
WARNING: shift/reduce conflict for GT in state 61 resolved as shift
WARNING: shift/reduce conflict for LT in state 61 resolved as shift
WARNING: shift/reduce conflict for ET in state 61 resolved as shift
WARNING: shift/reduce conflict for GTE in state 61 resolved as shift
WARNING: shift/reduce conflict for LTE in state 61 resolved as shift
WARNING: shift/reduce conflict for NE in state 61 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 62 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 62 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 62 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 62 resolved as shift
WARNING: shift/reduce conflict for GT in state 62 resolved as shift
WARNING: shift/reduce conflict for LT in state 62 resolved as shift
WARNING: shift/reduce conflict for ET in state 62 resolved as shift
WARNING: shift/reduce conflict for GTE in state 62 resolved as shift
WARNING: shift/reduce conflict for LTE in state 62 resolved as shift
WARNING: shift/reduce conflict for NE in state 62 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 63 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 63 resolved as shift
WARNING: shift/reduce conflict for GT in state 63 resolved as shift
WARNING: shift/reduce conflict for LT in state 63 resolved as shift
WARNING: shift/reduce conflict for ET in state 63 resolved as shift
WARNING: shift/reduce conflict for GTE in state 63 resolved as shift
WARNING: shift/reduce conflict for LTE in state 63 resolved as shift
WARNING: shift/reduce conflict for NE in state 63 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 64 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 64 resolved as shift
WARNING: shift/reduce conflict for GT in state 64 resolved as shift
WARNING: shift/reduce conflict for LT in state 64 resolved as shift
WARNING: shift/reduce conflict for ET in state 64 resolved as shift
WARNING: shift/reduce conflict for GTE in state 64 resolved as shift
WARNING: shift/reduce conflict for LTE in state 64 resolved as shift
WARNING: shift/reduce conflict for NE in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 65 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 65 resolved as shift
WARNING: shift/reduce conflict for GT in state 65 resolved as shift
WARNING: shift/reduce conflict for LT in state 65 resolved as shift
WARNING: shift/reduce conflict for ET in state 65 resolved as shift
WARNING: shift/reduce conflict for GTE in state 65 resolved as shift
WARNING: shift/reduce conflict for LTE in state 65 resolved as shift
WARNING: shift/reduce conflict for NE in state 65 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 80 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 80 resolved as shift
WARNING: shift/reduce conflict for GT in state 80 resolved as shift
WARNING: shift/reduce conflict for LT in state 80 resolved as shift
WARNING: shift/reduce conflict for ET in state 80 resolved as shift
WARNING: shift/reduce conflict for GTE in state 80 resolved as shift
WARNING: shift/reduce conflict for LTE in state 80 resolved as shift
WARNING: shift/reduce conflict for NE in state 80 resolved as shift
